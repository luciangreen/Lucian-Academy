New Bots 2

1. The bot hand-wrote algorithms by thinking of original versions of noumena. I developed 50 algorithms for a pass and 250 for a high distinction instead of 16k algorithmic breasonings. The larger number was too difficult as there was no way to vet such a large number. I found out about the student by mind-reading their algorithmic skills. I developed 250 algorithms for each sale and high distinction.
2. The bot checked the code with types as they word-processed it, with chains of 50 algorithmlets (sic) to finish a line. I mind-read the algorithmic spec, cosmology, song line, GL word, movie line, BAG output, philosophy sentence, algorithmic comment, shift sentence, another sentence said, thought or written in one's life, or image, finding the input, output, method, and test cases. I mind-read skills, with words and letters matching them that make sense. This method required neuronetworks.
3. The bot collected algorithmlets about formats for their algorithm or critically held each step to make it intuitive. I invented algorithms based on the highest quality ways of thinking. I checked the whole algorithmic database for the best way of thinking to use at each point, simplifying to simple and advanced types. I invented formats, reusable formats of data that made algorithms compatible with each other. There were intermediate formats in cosmology that the user could mind-read in themselves to connect to write algorithms.
4. The bot checked algorithms generated by neuronets. If I couldn't run an algorithm, I mind-read myself about ways to correct it. I started by thinking about the significance of a GL word such as "art" in forming the specification, such as creating a walkthrough or influencing the algorithm with a diagram. I traced its commands' types, comparing the extent to which the spec-to-algorithm could generate its pattern-matching component, leaving a CAW specification to complete. I rescued CAW commands with the correct types from the proper place in the corrupted algorithm, plugged them into the pattern-matching algorithm and checked the result.
5. The bot grouped by consecutive numbers that were part of the same number. I wrote a program finder for grouping consecutive numbers or patterns that formed a number or a term. I started with algorithms that did these things and merged them, finding patterns that other methods may miss. I used an algorithm generated with spec-to-algorithm and inserted type verification commands to differentiate appended clauses. I used pairs of append commands to get sequences of tokens until a condition was met.
6. The bot said that besides repairing code, they checked the necessity of every command, clause, and predicate using Lucian CI/CD. If I couldn't secure an attention-attracting algorithm using a neuronet for an employee's shift, I used Combination Algorithm Writer (CAW). CAW might take minutes to write several commands or short clauses. Despite being slower, CAW could find results more accurately. It could be used to repair or finish corrupted or unfinished algorithms, finding efficient and correct code.
7. The bot added Lucian CI/CD as a module to Spec to Algorithm. In Spec to Algorithm, I used subterm with address instead of predicates to search for values in terms and replace them with variables. Subterm with address found the address of values in terms, allowing substituting variables into these positions after determining which variable names to choose. The values were replaced with unique variables in a one-to-one correspondence and replaced with constants from the original data if they were the same across specs. Later, I generated predicates as an exercise for expandedness.
8. The bot converted models to useful Prolog algorithms. I found input to create and run algorithms with Spec to Algorithm by running the Strings to Grammar try predicate, which found recursive predicates and later mapped their variables to the output variables of the recursive structures of the output. These recursive structures allowed other sets of input in the same recursive structure as the model input to be transformed into the recursive structure of the output and its expansion. After finding the unique variables, recursive structure and constants from the input, subterm with address queries were found from the recursive structures. For example, the input [1,2,3,2,3,1,2,3,2,3] is converted to the recursive structure [r,[1,[r,[2,3]]]]. If there is another spec [r,[1,[r,[2,4]]]] and the generated algorithm is
[r,[1,[r,[2, B]]]] where 1 and 2 are constants, and B is a variable, then giving the new input [1,2,5,2,5,1,2,5,2,5] means the output's recursive structure [r,[2, B]] provides the output with [2,5,2,5]. More importantly, proximity formats are needed to give [A],[A, B]->[B].
9. The bot stated that there was no other easy way of solving the "teleporting train tracks" problem of mapping input to output in Spec to Algorithm than using subterm with address. Spec to Algorithm can flatten a term by representing item types by items of that type, running Spec to Algorithm, replacing these constants with type-checking commands, and copying the inputs to output without brackets. The general term's input is given by strings, atoms, numbers, and lists in any position and is repeated. In this case, indices of list items continue and do not restart when traversing the output's recursive structure. Continuing is the default.
10. The bot didn't need recursive loops for non-deterministic data (which wasn't required) but took variable values from the new data, ignoring non-constants from previous data. I converted recursive structures into output by traversing the data, continuing, and not restarting the indices of recursive parts. I traversed the structure, recording numbers until a recursive part. When I had reached a recursive part, I traversed the contents, recording a variable value 23 from the data (which was not in 123232323 1242412424 patterns like the specs, but a single 1232412423 pattern from input), continuing to 24 on repeat, then 24,23 after the next repeat. The 1 in the output may be replaced with a 5.
11. The bot turned optional structures on in strings-to-grammar but off in spec-to-algorithm to prevent ambiguity when outputting results. In addition, I turned optional structures in input in spec-to-algorithm off to keep structures the same. If an optional structure were in input in spec-to-algorithm, its contents would be stored in variables. However, the lack of an optional structure in the output needed for determining output wouldn't correlate with the input structure. For example, an optional structure in input may prevent recognising it in output, requiring individual variables to be copied, possibly undesirable in an algorithm. Optional structures may be acceptable with non-determinism from multiple specs.
12. The bot verified inputs and outputted the results with an algorithm generated by Spec to Algorithm. I checked that recurring variables didn't have conflicting values. Within the current level of A in [r, A], I checked that instances of the same variable didn't match more than one value from the input. I found and set the variable to the value the first time it was mentioned, then checked that subsequent mentions of the variable were set to the same value. If they conflicted, the input-getting process and (generated) algorithm failed.
13. The bot wrote plans, pedagogy, copywriting orders, chatbot questions and prayer songs to work the algorithm out. I found unique variables, recursive structures, and constants in that order because unique variables, which were one-to-one mappings of values to variables (the same across the specs), were needed before finding recursive structures and, later, input-output mapping. Constants, the same value in recursive structures across specs, could only be found after finding recursive structures. I checked the order of variables in each spec was the same for correctness. The order of variables in the new data set given to the generated algorithm was assumed to be the same.
14. The bot only processed variables on non-deterministic branches when needed, finding mappings at the start and output for each branch based on the single input spec. I merged recursive structures with different shapes from specs using a decision tree. This non-deterministic tree allowed choices within the recursive structure to find different outputs from inputs. These followed recursive structures, with non-deterministic choices within them with new input-output pairings. Due to the decision tree, there was a single non-deterministic tree, and the algorithm needed to branch and process variables before the next branching point within a new branch of the algorithm.
15. The bot stated that programs with CAW content may have multiple levels of processing but recognisable results. I converted the subterm with address algorithm to the expanded algorithm. First, I stored the input in recursive structures using its previous algorithm and used the match predicate from List Prolog to move the input to output using the recursive structures. Alternatively, I formed predicates and grammars from the recursive structures that stored the input, then generated predicates from the output recursive structures to create output, taking copies or continuing to process data, starting with the base (precisely, the start of the base) level of output lists and building the output from input. Needed input lists and values were passed to the output predicates, making code more accessible and understandable.
16. The bot gave the input and output recursive structures with Spec to Algorithm resolved variables mixed with unknown variables to CAW, and it found the new rules. I gave CAW specifications with complete results, including stages of computation, for example, results of predicates or times a predicate was run before running itself recursively, including recursive predicates called. These complete results included all computed values, not simply a truth value for their completion. If the algorithm found was recursive, it was partially found using Spec to Algorithm, and the remaining inputs and outputs were joined with CAW. I imagined stages of the algorithm and refined details as I went.
