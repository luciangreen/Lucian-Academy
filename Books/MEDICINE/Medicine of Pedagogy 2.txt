["Green, L 2024, <i>Medicine of Pedagogy 2</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Medicine of Pedagogy 2

1. The medicine student checked the data types with a state machine that accounted for functional calls. I developed a functional types system for State Saving Interpreter (SSI). Functional types were functional calls inside type statements. For example, \"a :- b(c). b(C) :- C. C :- terminal.\" They provided intermediate predicates that could call other \"type predicates\".
2. The medicine student distributed type calls in the type statement, simplifying the type statements. I could call types in the form \"a(b(c)).\". In the first example, the type statement \"a\" is passed the argument \"b(c)\", then \"b\" is passed \"c\", which is then called. Or, I could call them in the form \"a(b,c).\". In the second example, the type statement \"a\" is passed the arguments \"b\" and \"c\", which are then called.
3. The medicine student combined functional and recursive types, in \"a(C) :- C. a(C) :- b, a(C).\" to recognise \"b, b, c\". In recursive types, base cases could have extra items. Recursive types were, for example, \"a :- b. a :- b, a.\" This checked that the data types all had type \"b\". The base case could be modified to \"a :- b, c.\" so that the data types \"b, b, b..., b, c\" were recognised.
4. The medicine student passed multiple \"type arguments\" to be tested. I inserted a predicate checking data types using a command in a predicate. For example, \"a(B) :- number(B).\" Or the functional types could be passed and tested, for example, \"c(A1, D(E)) :- A1=[A2], D(A2, E). a(B, E) :- E(B).\" with the query \"c(1, a(number))\" tested \"[1]\". This method was useful if various types were wrapped in square brackets.
5. The medicine student was suspicious of free variables and constrained them with types. Functional calls could use the same notation in the way of functional types. For example, when the predicate \"a(B,C,E) :- B(C,1,E).\" is queried with \"a(+,2,E).\" it returns \"E=3.\" This feature allows peeking inside algorithms, selecting the right predicate from a set or quickly finding algorithms using induction. An inductive algorithm could take \"can_be(A,+,-,*,/). A(1,1,2).\" and return \"A=+.\".
6. The medicine student simplified the command not to have data. The inductive language could find algorithms, find sets of commands or optimise sets of commands. When writing an algorithm, I inserted a \"mould\" variable, the answer to which I \"set\" later in the algorithm. I could constrain sets of commands by number of commands, recursion, type of search or domain, such as translation or grammar check. I could optimise sets of commands using natural language and styles, such as \"set the reference value to 0\", \"change from explicit to implicit list decomposition\", or \"prepare the Prolog code to be converted to C\".
7. The medicine student also used a pretty printer to align the code. In Lucian CI/CD, I preserved the formatting of converted algorithms. I kept the formatting with the converted List Prolog code. This formatting could be reused when the code was put back together by Lucian CI/CD. The formatting preserved the look of the code, the comments, newlines and intra-line comments.
8. The medicine student visually presented the diff'ed code and found combinations of changes. I used the Linux diff command in Lucian CI/CD to find differences between text files rapidly. I found additions. I also found deletions. It was fast.
9. The medicine student found the best build from changes. In Lucian CI/CD, I found every changed line rather than chunks of changed lines. I found these using diff. I didn't want groups of changed lines in case combinations of these changes couldn't separate specific changes. I found combinations of every changed line (addition or deletion).
10. The medicine student used a pretty printer to align code from other programming languages. I supported other programming languages in Lucian CI/CD. I converted them with their converter. I found the function or predicate dependencies and the configuration of lines in the functions base-up. Their formatting was preserved.
11. The medicine student also compensated for comments embedded in predicate headers. I preserved intra-line comments. For example, I read the line \"A /* this is A*/ is 3,\". I recorded the comment after the command but was able to reconstruct the line by preserving the formatting. These lines were linked. They were treated as a unit when combining changes in a build.
12. The medicine student compensated for commands that couldn't be predicted with specifications, such as input, random or APIs. I compensated for global variables in Lucian CI/CD. Global variables usually weren't included in a predicate specification. So, any code after a global variable assignment shouldn't be processed using find dependencies but with the classic \"all predicates together\" algorithm. The find dependencies algorithm could be used if globals were recorded with a specification. Code after the global variable assignment that didn't refer to the global variable could also be processed using find dependencies.
13. The medicine student preserved the formatting of commands. In the converter, I recorded the string with formatting. I split the string at the end of the command. If there was an embedded comment, it was labelled and kept. There may be multiple embedded comments in a command.
14. The medicine student preserved the formatting of commands. I split on a new command. This split occurred at the start of the line with the new command. If there were two or more commands per line, they were split at the start of the command. I grouped lines with a single command over them.
15. The medicine student quickly found the feature they were searching for in the code. Lucian CI/CD stored Prolog, not List Prolog. It worked out List Prolog from it. GitL, a version control system, displayed diffs of Prolog code found with Lucian CI/CD. Users could take a version and use it as the current version.
16. The medicine student set the number of spaces per indent. The user used the List Prolog to Prolog pretty printer rather than preserving formatting when assembling code. This action had the advantage of pretty printing indented levels of code. If code was built with particular indenting, it was \"pretty printed\" in this way. Comments and newlines (also in comments created by the converter) were preserved.
"]