Medicine of Meditation 2

1. The medical students uploaded their files to their server, testing them on different platforms. I prepared to commit the new files. Lucian CI/CD and GitL gave me experience writing DevOps (CI/CD) software and a version control system. With Lucian CI/CD, I could use free DevOps software to customise and automate. In addition, I could bug-fix nested predicates in findall in SSI by running non-nested and nested predicates in findall.
2. The medicine student functionally decomposed the get and put variable parts in match4 in List Prolog on the way to writing long-form code. I prepared to upload the new files. I checked and fixed the files with Lucian CI/CD. I asked the open-source Prolog developer if a non-nested predicate was better than nested predicates in findall. A non-nested predicate in findall was faster to process and did not require a long interpreter loop.
3. The medicine student used a program finder found with Combination Algorithm Writer (CAW) to keep the code as simple as possible. I checked that the tests in Lucian CI/CD were successful. I tested my repositories each time after adding new plug-ins, such as reverse-optimisation possible simplicity triggers, where (if code was saved in long form) code was converted to short-form code, which could be simplified or corrected, for example by inserting reverse before and after group_into_clauses10 in Lucian CI/CD to test bottom-up rather than depend on predicates that hadn't been tested and saved, perhaps with a program finder that was customised to do this. This program finder detected if inserting two reverses around a call would correct the output to the desired result. This technique also inserted an intermediate predicate as the call was to a recursive predicate and the call to the predicate with this call needed to be modularised (although it could be put into the body of the main predicate).

4. The medicine student identified and removed unnecessary code using Lucian CI/CD by adding "bypass predicate" lines to the source code. I tested the workings of Lucian CI/CD itself by adding new commands to Lucian CI/CD that were in it. I read the source code to check and wrote down the commands Lucian CI/CD didn't have. I added these to Lucian CI/CD, particularly the Prolog to List Prolog converter used by Lucian CI/CD. I ran Lucian CI/CD on itself to check the source code was as simple as possible, using Lucian CI/CD's tests to generate tests for it in the interpreter.
5. The medicine student found all possible new inferred connections through existing word neighbours in texts with the Breasoning Algorithm Writer (BAG). I demonstrated thoughts of the right quality and number with BAG. I used BAG rather than stamps with pre-saved BAG output to become immortal, as I had learned from writing the software that writing it and what it did were necessary to meet the "computation" requirement of immortality in one's home time. The leader recognised these thoughts and rewarded the people who represented them. BAG was my version of a neuronetwork. It was based entirely on my theory and plugged into my philosophy.
6. The medicine student saved a copy of the passing files to approve. I authenticated that the files had passed Lucian CI/CD's tests. It was the log. I could list the predicates, their possible changes, and the test they passed. I could also reference archives or plug-ins from which possible replacements had come.
7. The medicine student found the outputted files and replaced the files in the repository with them (or copied them from GitL, ran Lucian CI/CD and saved them in GitL). Lucian CI/CD moved passing files to the repository. A shell script automatically copied these files to the GitL archive. The files' version was increased and moved to production systems for further testing. The specifications of these systems were recorded and reported.
8. The medicine student wrote in assembly language with a minimal, customisable register state machine. I backed up the old files in Lucian CI/CD. Separately, I defined universal assembly code as able to be run in Prolog. It had a register state machine. I wrote an algorithm in Prolog, tested it with Lucian CI/CD and converted it to assembly language.
9. The medicine student claimed that converting to short form was part of partial evaluation, an optimisation technique. For example, parts of the query could be used to shorten the short form code (i.e. if specific ancestors were wanted, data collection could first find ancestors, then a subset of the tree), and then the code could be converted to interpreter-free long form code. In this case, partial evaluation simplified the code. I listed the repositories that the algorithm had modified. I converted foldr to long form (a predicate that didn't require backtracking). This expansion was similar to the following, with another command instead of append:

foldr_append([],B,B) :- !.
foldr_append([A1|A2],B,C) :-
 append(B,A1,D),
 foldr_append(A2,D,C),!.

I backed up the changed files, which were then converted to long-form before being compiled in C.
10. The medical student went back to the original files if a test hadn't been written correctly or the long-form predicates didn't pass. I backed up the old files and folders, including invisible files, in the original repository. I stated that maplist/2, /3, and /4 were in long form if the called command was also in long form. I converted the called command to long-form to speed up maplist by writing it in long form. Two sentences were connected from the shared language in the connection.
11. The medicine student ran Prolog on the emulator. I moved the new files and folders into the repository. I wrote a CPU emulator with binary addition, such as 0+0=0, 1+0, 0+1=1, and 1+1=10. The logic gates, composed of transistors, computed these results.
12. The medical student spent equal time in the present and future before investing necessary pedagogy in both worlds and spending more time in the future. I inputted lines as strings to split into tokens before unit testing. I ran Lucian CI/CD in line mode to work with programming languages other than Prolog. I removed and re-added end-of-command delimiters (and catered for the function header being allowed by itself), identified, rewrote and replaced functions and added the end-of-function syntax. I could check and modify C, assembly and other code.
13. The medicine student auto-solved the load problem by checking the system was clean and optimising the software. I ran Lucian CI/CD with settings for different testing stages. I could create and assort tests by stage, with some tests automatically passing (i.e. "a(_,_).", without needing "true."). Unit tests were tests testing the whole algorithm, integration tests (if required) tested that changes worked, end-to-end tests tested the entire algorithm, including installation and removal, user interface tests tested user input and interface appearance and clarity and continuous delivery tests such as load testing and API integrity testing. The algorithm should be able to bear the load of many users and should provide errors and connection errors and solutions.
14. The medicine student found tests with Program Finder with Types as a last resort. I called Lucian CI/CD to find tests with particular labels for other repositories. I retrieved and modified tests from different repositories, such as for a compiler that ran the same programming language as the interpreter. I modified the interpreter and compiler so that they ran the same tests by using "a :- b, ! , c. a :- d." instead of "a:-b->c;d." and eliminating duplicate predicates. I considered rewriting the interpreter and compiler to use this method when interpreting if-then (->/2 and /3).
15. The medicine student found type errors in a predicate with particular modes. I called Lucian CI/CD to find tests with specific labels for other modes. I found the modes of a predicate (i.e., which arguments were inputs and which were outputs). I found its possible tests for these modes with PFT. PFT found tests by tracing the types of variables with particular modes through a predicate, giving the types and, therefore, possible tests of outputs.
16. The medicine student researched and corrected the interpreter's weaknesses and slowness. I ran unit tests. For example, unit tests in List Prolog tested each command and algorithms with these commands. I generated unit tests with all possible combinations of commands and recursion to a certain depth to rigorously test various features. In addition, I tested all possible modes of commands.

-a not a
graphics, 
music on computer sim
prolog on computer sim in assembly code
compile Prolog to assembly code
long form to assembly code (nested loops
and member! to a long-form pred)
computer sim with more memory, 
able to run in a container, 
transistor (logic gate) sim
