Education on Pedagogy 2 1

1. The lecturer tested for the simplest Lucian CI/CD combinations with Spec to Algorithm. Lucian CI/CD tested the combinations for the simplest ones by finding the S2A and CAW commands to optimise the code. Like the S2A Optimiser, this step was followed, attempting to find the command for the whole algorithm, then top-down, not bottom-up. The specs came from the tests and types from the predicate and below. To prevent errors in types from the predicate and below, Lucian CI/CD first found types from them and then optimised the code using the above method.
2. The lecturer added an S2A module to Lucian CI/CD in GitL. I wrote GitL with S2A. GitL is a version control system that stores versions of repositories in a list of folders, displaying the results of "diff" between the changes and the most recent version. GitL recursively loads files from disk with their path, diffs them with the repository, and saves them. Diff finds insertions and deletions from one file to another by processing one character at a time with S2A.
3. The lecturer pattern-matched items using S2A or lists using CAW. I wrote Strings to Grammar in Spec to Algorithm. Strings to Grammar found the recursive structure of a list of characters, including repeating patterns by searching for a repeat of the first character, then recursively searching for repeats of the next character, testing the sequence from the repeating character to before the next one for equality with sequences following it. S2A found the recursive structure with its grammar-finding algorithm. Alternatively, subterm with address could be modelled with S2A to redesign S2A by using a counter to track the dimensional address of subterms being found.
4. The lecturer explained that Mini CAW grounded both input and output for further optimisation. I wrote Spec to Algorithm with itself. S2A used "try" from Strings to Grammar (S2G) to find recursive structures, found constants that recurred in all the same positions in specs with the same shape, a decision tree to merge shapes with the constants, and in the algorithm, substituted data into the recursive structure, mapped input to output using the map found earlier and rendered the output from the filled-in recursive structure. It found the constant 1 in [a,1],[b,1] by finding terminals' addresses using subterm with address and saving the same items in the same addresses as constants with CAW. It found the decision tree [a,[nd,[[b],[c]]]] where "nd" denotes two non-deterministic branches from [a,b] and [a,c] by using sort, findall and recursion using CAW.
5. The lecturer substituted values into lists or recursive structures because arbitrarily long lists and their decomposition necessitated CAW. I substituted data, [1,2,3,2,3], into the recursive structure, [1, [r, [A, B]]], in Spec to Algorithm to produce [1, [r, [2,3]]] by using CAW. This action involved substituting or verifying values and recognising and matching repeating patterns. I also verified values contained by types, substituting or verifying these values. In addition, I saved previous variable values for future verification.
6. The lecturer inserted true or false at the end of specs, representing positive and negative cases (whether the spec returned true or false), used in CAW I mapped input, ["a",3], to output, 'A1' using the map [[1,1],[1]] found by Spec to Algorithm to "a". This involved getting item 1, "a" of item 1, ["a",3] of the input with subterm with address and substituting it for item 1, 'A1' of the output, giving  "a". I bug-checked S2A, making single items such as "a" possible to process and output. I gave queries to S2A in the form s2a([in1,in2],[out1], Algorithm) to find the algorithm for sets of inputs and outputs.
7. The lecturer used A=B with simple data or s2a(Complex_A,Complex_B) for complex data that required multiple predicates otherwise. I researched how much data meant subterm with address performed better than complex predicates (such as nested lists). Subterm with address bypassed the overhead of using predicates and recursive structures, mapping input to output in recursive structures using subterm with address and rendering output from the output recursive structures. I determined that predicates were more efficient if there were far fewer pieces of data and the complexity of the data was low. In addition, I determined that subterm with address was preferable if there was comparatively more data and the complexity of the data was high, as predicates have high overhead if not necessary compared with subterm with address, which ran the same predicate and could be optimised, as well as compiled efficiently.