["Green, L 2022, <i>Immortality 6</i>, Lucian Academy Press, Melbourne.","Green, L 2022",1,"Immortality 6

1.  I presented the progress bar for converting List Prolog to C.  I could run batch file manipulation commands using Prolog. First, I created many files using an algorithm.  Then, I inputted these files into another algorithm to produce more files.  I scheduled this operation regularly.
2.  I debugged the C code in a Prolog form (using a C to Prolog converter).  I converted the Prolog list to an array of items in C without the string to list algorithm.  I converted A=[B,C] to A[1]=B and A[2]=C.  If B or C were lists, I pointed to new lines of the array, i.e. A[y][x].  B or C could be numbers representing letters, lists, etc.
3.  I tested whether the predicate had any input.  I ran the Prolog algorithm with Lucian Prolog.  I ran converters.  I ran interpreters.  I could run the algorithm online.  I included command line arguments and other flags for Prolog, such as initialisation.
4.  I attempted tabling as much as possible, reporting whether the interpreter had used tabling when timing the algorithm.  I registered that the false speed increase was due to tabling, not the program being efficient.  I reacted to the program finishing instantly.  I realised that Prolog had recorded the results from the last time I had run the program, registering no change to the program since the last time I ran it instead of computing it instantly.  I made the necessary changes to speed it up.
5.  After eliminating unused variables, I used functionalism and reused parts of state machines, converting them to predicates.  I wrote a Prolog algorithm to C converter that converted findall to loops and omitted unused variables and code.  I could also make additional converters to and from List Prolog to a state machine.  I could eliminate unused variables in the state machine.  I analysed the algorithm like a maze, eliminating unused dead ends.
6.  I eliminated non-determinism and choice points in my program and wrote it in C.  I used native C in Prolog.  I wrote the string processing predicate in C for speed.  I could also write the neural network algorithm in C or Python.  I started to write Prolog predicates such as sort in C.
7.  I eliminated extra brackets and superfluous A=B and wrote a neural network to simplify code. Next, I converted C to a Prolog State Machine to remove unused variables, etc. Next, I wrote a version of my algorithm that didn't produce output while I ran it to cut down on code. Next, I replaced code with tabled results only if the code was simple and could cope with all possible data. Finally, I converted from the Prolog State Machine to List Prolog, then C, for better performance.
8.  I wrote simplified machine language algorithms using CAW or neural networks.  I accomplished this by writing machine language code for the processor.  First, I used the machine's instructions to write the code. Then, I converted C code to machine language using an interpreter.  I also converted machine language to C if necessary.
9.  I also used Program Finder with types to design circuits and machine language.  Lucian Prolog loaded and ran Prolog algorithms in interpreter mode.  I could load algorithms and trace and save traces to disk (using protocol).  Using the interpreter, I ran a version of CAW with particular parts of predicates and possible choices of variables similar to other predicates.  CAW used a program finder with types to identify likely functions required.
10.  The application had a version number, which I recorded as compatible if it was part of another program's package.  Lucian Prolog compiled itself with algorithms.  The compile command saved the interpreter converted to C with the algorithm in Prolog.  Compiled algorithms could run by themselves.  They could be distributed as binaries and run straight away.
11.  I checked the predicate had the right trace in the test.  I checked the label of the choice point accessed each time and referred to predicates by ID.  Later, I redrafted the software, eliminating complexity and bugs.  I also used a single number to number choice points.  In addition, I labelled variables in memory.

12.  I also wrote shell.  I wrote the writeln command in building language, a way of programming the processor.  I wrote writeln by writing the string to output.  Then, I outputted it to the terminal.  I also wrote the terminal app.
13.  I saved the character code.  Then, I wrote the get_character command in building language.  I did this by getting the character from user input, a file or a stream.  Then, I waited for and got the character.  Finally, I recorded the character code.
14.  I returned a result from the function and scanned for unused variables.  The function returned a single value.  The other variables were local.  I didn't need to use a command to maintain the immutability of variables.  I didn't need to use a command to save variable values locally and delete them afterwards.
15.  Transformations and operations involving all instantiated values could return a truth value based on their success.  I wrote the end of the function symbol.  I represented variables and functions similarly.  The interpreter had no choice points; it just dealt with them.  I fed the logic of statements such as equals4 and predicates to a result via nested if-thens.
16.  I warned about cyclical includes statements and missing files.  I wrote the statement to include a library.  Then, I added the file's functions to the algorithm.  I tested for instances of functions with the same name and arity not together.  I warned about duplicate copies of functions.
17.  I produced the data with the algorithm.  I did this by writing the main function's name.  First, I ran the algorithm.  I did this by running the main function.  I could also pass argument values to the function.
18.  I generally kept a separate documentation file about the algorithm.  I wrote comments to help explain the algorithm.  I enclosed these in /* and */.  In Prolog, comments may also follow % or // in C.  I kept a copy of the file with comments in case a converter removed them.
19.  I also checked the conversion of the original from List Prolog to State Machine, and back was the same.  I did this by back-translating conversions to check them.  I also checked the original with Prolog and C converters.  In addition, I checked the original with List Prolog and Prolog converters.  I did this with C and building language converters.
20.  I attempted to find two other values given one value in a three-way conversion.  I wrote an inverse algorithm and back-translated it to check it.  I found an algorithm to solve 2x=2 for x.  I found an algorithm to substitute x=1 into the original equation to check it.  Also, I could do a three-way conversion between interpreter (output given program and input), induction (program given input and output) and constraints (input given program and output).
21.  I returned an error when back-translation returned different results.  I stored grammar elements such as \"{\" and \"|\" in a separate file.  I could customise these for various programming languages.  I wrote programming languages that I could convert back to the same language from which they were converted.  I wrote a grammar that could interpret any white space.
22.  I checked variables were defined in C using analysis in Prolog.  I converted the C algorithm from the Prolog algorithm to a Prolog algorithm.  I deleted the nested findall statements unless they were necessary.  I converted for loops, etc., into findall statements.  I converted parts into equals4, member and string to list commands, some in the predicate head.
23.  I wrote an algorithm that created findall from a for loop when possible.  I used the for command to represent findall, recursion, maplist, forall etc.  These commands had to return to their original form when back-converted.  I found for loops were faster than recursion.  I found and warned about infinite loops.
24.  The for loop could simulate choice points with loops ending at the end of the large predicate if it were possible to predict.  I initialised the for loop with i=1.  Then, I created a list of numbers representing output lengths or array indices with findall.  I used recursion if I couldn't use the index to process the data using findall.  For example, if the predicate processed previous results or used different predicates or bases cases, it should be a recursive predicate.
25.  In recursion, I could use the index to iterate through the list items.  I used the for loop with the test i<=10.  I created a list of numbers from 1 to 10.  I could use the number from this list to create lists of specific lengths.  Alternatively, I could use it to iterate through the same indices from arrays.
26.  I stored data structures, not sentences.  I could write printf(\"The integer is %d\", i) in C as I=5,foldr(string_concat,[\"The integer is \",I],A) in Prolog.  In this, foldr was foldl with reversed input.  I could write the output to the screen using writeln1(I) in Prolog.  In this, writeln1 was writeln1(Text1) :- term_to_atom(Text1,Text2),writeln(Text2) which presented the double quotes.
27.  I could recognise and format numbers as integers, with decimal places or n decimal places and other numerical calculations.  I could present a number with two decimal places: A=123.4567, B is A*100, round(B, C), D is C/100.  I could check that a number was close to 1 as follows: E=0.999,0.999999>E.  I could use this in the following: atan(1.55740772, A).  A = 0.9999999986411103.


28.  I returned a truth value for whether the operation had returned successfully.  I used foldr to operate on data recursively.  I identified the array or data structure.  I recognised the process on its current item.  I recognised the initial value.
29.  If it was a tree as an array, it needed a command to process the hierarchical structure at an item number.  I identified multiple-level foldr.  I used a predicate instead.  I noted that the predicate was called twice from within it.  I determined that the operation operated on a particular item number.
30.  I wrote a search predicate for co-ordinate mazes or trees.  I used foldr with multiple sets of input.  Foldr recursively transformed with one set of input.  It could transform with various input groups and search through data.  I replaced this with a predicate.
31.  I outputted a list of lists in C.  I wrote a multiple-level foldr with multiple input sets, which I replaced with a predicate.  It processed multiple lists of lists.  I stopped adding dimensions when necessary.  I performed a search with iterative deepening.
32.  I could use foldr as a substitute for maplist.  I did this by using a formula finder with maplist.  This formula finder identified the pattern of input and output at each point.  Then, I entered this pattern into maplist.  Or, I could substitute another formula into maplist.
33.  Commands either passed or failed and sometimes returned results. For example, I used forall to test that all list items had a property.  I started with the first item of the array. Then, I tested that each item in the array had the property.  Otherwise, forall failed.
34.  I deleted the garbage (which C automatically did).  I used find n solutions to return a command's first n or fewer solutions.  I made a variant that only passed with n solutions.  The current array always started with 1.  I took this array from another array.
35.  I found more algorithm connections more quickly.  I used the \"text to algorithm\" algorithm to store algorithms that connected vital words.  There was a direction from one term to another.  Hierarchies of other terms were involved.  I collected these and turned them into arguments in philosophy.
36. I wrote the rule with the types in mind.  I did this by writing the predicate with the program finder with types.  A separate algorithm from the program finder with types, the program finder wrote the function, perhaps with two lists, in a recursive predicate.  Once I wrote the rule, I could try it on the next item or find a new rule.  I could identify that the pattern of the data item was the same as a previous item to save time with the program finder with types.
37.  I could write base cases following the algorithm's aim.  I used a program finder with types for finding base cases.  Base cases are a form of a clause.  The recursive clauses already indicated the necessary base case.  In some cases, the algorithm revealed more base cases.
38. I could also use a duplicate predicate deletion method in Windows.  Similarly to Selective Linear Definite (SLD) clause resolution, I deleted identical predicates.  This method followed other optimisation techniques (such as deleting unnecessary variables and code, including variables that are always true or false).  I also used SLD to delete predicates that called a single predicate.  I called reused libraries.
39. Prolog encouraged writing ideas from scratch or using other libraries.  I kept only recursive predicates as an experiment, moving the others to larger predicates.  This method removed smaller, time-consuming predicates.  However, it increased the size of the local stack of the larger predicates.  So, I chose many small (not too small) predicates.
40.  I wrote a search engine to search for queries that described Prolog queries.  I wrote HTML documentation linking to Prolog tests. Third, I edited and ran the tests online. Fourth, I backed up and edited the code to work with the tests. Finally, I downloaded the program and searched for algorithms that satisfied a test.
41.  I tracked modifications of predicates and algorithms.  I collected predicates with equivalent specifications. Then, I determined whether I needed to write an algorithm. Fourth, I found the predicates different algorithms used. Finally, I found the patterns of the use of these predicates.
42.  I tested the expression b=c.  I gave variable names as variable definitions.  If the program gave no value, it gave the variable name as a variable definition.  I outputted the variable name as the variable definition if it didn't have a value.  For example, a=(b=c).
43.  I found the variable value from equals4.  When the program found a variable value, the algorithm substituted it into the variable definition.  In a=b, a=1, I found b=1.  The predicate returned this result.  The algorithm analysed this result.

44.  I could write the idea as a predicate, but findall was a more straightforward solution.  I wrote findall with variables that it can save between passes. Then, I wrote findall to find all the combinations of items.  I counted them as I went.  I stopped at a certain number.
45.  I could convert the call arguments in C.  Findall with recursion is like call. First, I did this by writing findall with recursion as a predicate.  Second, I added a base case.  Third, I added a query.
46.  Recursive findall could have member calls that carry copies of variables from the last iteration. In addition, Findall could output multiple lists.  Instead of one list of results, findall could output many lists.  Findall could or could not add to a list.  To allow findall to add to a list meant having different findall clauses.
47.  To avoid replacing variables, the algorithm renamed them, i.e. _001.  The call command can have types, including simple types, modes, and predicates passed as variables. First, I constructed the lists as arguments. Then, I wrote a predicate that changed [] to {}. Finally, I wrote variables without values substituting for them. 
48.  I returned results when findall failed and defined recursive variables in different findall clauses.  In findall with recursion, there are variables for the nth iteration and other variables.  The findall choice point included the current iteration number.  The choice point also included other outputted variables.  I initialised inputs forming these before running findall.
49.  Lists formed in findall may be hierarchies created with equals4 commands, and there may be shorthand recursive calls without predicate names.  Findall with recursion has no predicate name.  It can call itself using a findall name.  Variables in recursive findall are immutable, meaning they can be defined once.  They are saved between passes, can be arguments in further predicate or recursive calls, and need phi definitions so that they are determined at the start, even when the interpreter invokes a choice point in the middle.
50.  If variables from before the recursive findall predicate are needed, the programmer will duplicate them if they are changed.  Predicates or findall are in the form: Outputs of findall, Name of this output list, Inputs, Outputs of recursive findall, Body.  For example, A=[1,2],B=[3,4],G=1,findall([G,C,D],J,G,G1,(member(C,A),member(D,B),G1 is G+1)).  J = [[1, 1, 3], [2, 1, 4], [3, 2, 3], [4, 2, 4]].  In this, G takes the value from the previous pass of findall rather than the initial value.
51.  Cut affected the predicate and below, deleting more and more choice points.  I programmed cut with n solutions.  I could finish the recursive findall predicate after n solutions.  I could also finish it after n member, etc., results.  Or I could stop after a particular number of these.
52.  I could delete choice points from lower predicates.  I selected from the choice points in findall. Then, I deleted choice points from a particular member predicate.  Or, I deleted choice points from append calls.  Alternatively, I deleted specific choice points from a predicate.
53.  Instances of recurring variables in recursive findall before the recursive findall predicate are ignored on the second pass, like new recurring variables.   Findall with recursion is possibly flawed because sometimes I only wanted one solution from a buried choice point.  However, I could arrange to have the single choice point returned using cut.  In another case, I could flatten multidimensional data from recursion.  I could then sort this data, which eliminated duplicates.
54.  If the recursive findall returns [] as one output or fails, the algorithm may salvage variables from it or the head.  Findall with recursion is possibly flawed because the programmer may want to know if a predicate fails.  However, the algorithm may return an error when a pass fails.  In this case, a phi node is necessary to save recurring variables.  Additional code to catch undefined variables may be required.
55.  Outputting a list rather than a list of lists is possible with recursive findall, which is not possible with findall, preventing the need to flatten output afterwards.  Findall with recursion has extra outputs like findall.  The programmer may input these outputs from before the recursive findall predicate.  Or, the programmer may input them from just before the second pass onwards.  In addition, recurring outputs that are different from the outputs are outputted, reporting the number of passes, for example.
56.  I had to be careful that I defined certain variables in the recursive findall predicate before the member choice point in a phi node, triggered before the member call.  I can convert recursion with findall to C (a.k.a. \"pre-phi C\").  As an aside, I could forego the classic findall output and additional output variable in recursive findall because the recursive findall input and output could replace this with append.  The interpreter finds the input to recursive findall from before the recursive findall predicate before the first pass and from outputs of the recursive findall predicate on the second pass onwards.  Also, member, etc., choice points in the recursive findall predicate can load inputs from the last pass's outputs.
57. I stated that [a]:b,c was an error, but that [a]:[b]:c and [a]:[b,d] weren't.  I can append using \":\".  Taking a=1,b=[2,3], [a|b] and [a]:b are equivalent.  Using these values of a and b, interpreting a:b would produce an error.  Note: [a]:b = [1,2,3].
58.  I could also write string_length(L,1), string_concat(L,_,\"abc\") instead of the reverse order of these commands.  I can find the first n items and the rest (n+1 to the list length) items.  The first 2 items of [1,2,3,4,5] are [1,2].  The rest (2+1=3rd to the 5th item) are [3,4,5].  I could use a similar process on lists of characters.
59.  For customisability, phi nodes may be at the middle or end of the recursive findall predicate.  I can reverse lists in findall.  In recursive findall, I could write append with the first two arguments swapped to reverse a list built with recurring variables (passed between passes).  List processing after member could process multiple list items at a time.  Member after list processing could find combinations of items, while the program could use phi nodes when choice points skip over list processing.

60.  When the loop finished, I outputted the appended result.  I may not need findall list outputs.  Instead, I treated recursive findall without member calls but with list processing as a while loop.  One clause (in fact, an if-then clause) had a base case with the cut command.  Another clause had the list processing code.
61.  I didn't need to return through the levels with recursive findall, which had more possible options than findall.  Separately, an alternative name for recursive findall is \"recursor\".  A name for the interpreter algorithm is \"interpret\".  A name for the induction algorithm is \"induct\".  A name for the constraints solver is \"constrain\".
62.  Recursive findall variables are immutable, so the programmer couldn't redefine them.  A member call followed by another member call in recursive findall creates new logical conditions.  I investigated the C version of recursive findall.  Classical findall converted member calls to loops, with nested if-then clauses to catch failure.  Recursive findall added recurring variables, which needed to be deleted in second and onward copies of the clause if they occurred before the recursive findall clause.
63.  I saved time running reverse with recursive findall.  Logical conditions of recursive findall are that it needs a base case and keeps findall-style output, but not this last condition in the following case.  For example:

A=[1,2,3],L=[],findall(classical_output=[],recursive_input=[A,L],

body=   ((A=[],L=O,!)->true;
        ((A=[H|T],append([H],L,O))
        )),
classical_output_variable=_,recursive_output=[T,O]), which produces the output O=[3, 2, 1].

Alternatively, I could write this:

A=[1,2,3],L=[],findall(classical_output=[],recursive_input=[A,L],

body=   ((A=[],L=O,!)->true;
        (A=[H|T],O=[H|L])
        ),
classical_output_variable=_,recursive_output=[T,O]).

64.  I could write recursive predicates as if they were loops.  A condition of recursive findall is a base case for each instance of the member call.

On another note, I could write:

A=[1,2,3],L=[],findall([[ri=[[],L],

b=[],ro=[[],L]],
        
        [ri=[[H|T],L],

b=[],ro=[T,[H|L]]]]).

Or, in the first clause, I could write ro=ri.

65.  A condition of recursive findall is that functionalism can be used in recursive findall to save time.  Instead, I could use \"afunctionalism\" (sic), where the bodies of the findall clauses were empty, and I called no functions.  I needed to take care to label the function in a comment.  The new findall command was afunctional because it didn't require an external predicate.  Because recursive findall didn't need an external predicate, I didn't rename, pass and lose variables.
66.  When the findall body, which variables may partially define, runs out of choice points, findall ends.  A condition of recursive findall is that when a member runs out of choice points, recursive findall returns the current iteration.  As a note about the previous paragraph, I could use functionalism at any point of the findall predicate.  I could define variables as an ri or ro label.  I could define variables as the body or parts of the body.  I could also define variables as ri=..., ri=ro, or the whole findall clause.
67.  I reduced the complexity of algorithms in C to process lists to process array items.  A condition of recursive findall is that I could alternatively use existing findall and numbers/4.  I could run numbers(4,1,[],N), producing N=[1,2,3,4].  I could reverse this list and use a predicate to get the nth item of a list, to reverse a list with findall.  I could convert both findall and recursive findall to an iterative C loop.
68.  I could convert findall*1 and recursion to C, treating them like recursive findall (*1 - using recursive input and output to store the classic output).  An example of recursive findall is creating a Prolog state machine. First, I numbered the lines while they were in hierarchical (list) format. Then, I converted this hierarchy to a linear list of states, with state numbers resembling go-to lines from the original algorithm.  These steps were done one after the other and were like recursion without the returning variable in the base case.
69.  Immutable variables that can't be set to a value when they already have one prevent over-writing and lead to better logic.  I can convert recursive findall to a for a loop.  For example: for i=length of list to 1, a=list[i]:a, next i.  This program reverses a list.  Immutable variables were more intuitive than non-immutable variables.

70. I could also wrap recursive findall in find n solutions. If the find n solutions command has a counter, so can recursive findall. Find n solutions counted the first n solutions. Recursive findall could also count a certain number of solutions. Recursive findall is recursive despite not returning through levels on the way up because it effectively calls itself.
71. In recursive findall, choice points back to, e.g. member contained variables from previous recursive findall passes. The second instance of the member command, etc., can contain variables. When the interpreter back-tracks to a member choice point, it returns to a set of statements before the member command, containing recurring variables. Alternatively, these inverted phi nodes could be phi nodes at the end of the recursive findall body. If the programmer needs to synchronise the member call with a previous member call, there could be a single call to, e.g. member(_,[1,2,3]) for three list items to synchronise.
72. I could verify, zip or reverse lists. Alternatively, member calls may be linked together. For example, member(A,[1,2,3]), A could help retrieve the Ath list item. Or, it could help recover the A+1th list item. Or, it could help retrieve the 3-A+1th list item.
73. I also checked whether interpreter predicates were needed by the interpreter, eliminating ambiguously typed predicates. I wrote a command that adds commands and variables to the State Saving Interpreter. The interpreter prevented each command from being a recursive predicate's name. Each command had an entry in the multilingual dictionary. I could switch commands on and off, depending on whether the user might need them in the algorithm.
74. I included specific modes of commands. I could switch commands on or off in the compiler. I used a command if it was in the program. I used all commands indicated by a call command. I checked whether the call command was open-ended or contained items from a constant list.
75. I created the personalised email. I did this by making a no-code editor with the State Saving Interpreter. I wrote a text file with databases. The file also had report templates. It also had manipulation operations.
76. I could edit multiple fields at once. I wrote a user interface for the no-code editor. I reused the edit page. Both the administrator and user could edit their details. I added the field to edit to the process.
77. I generated images, HTML lectures and saveable HTML pages with Prolog. I wrote a graphical user interface for the no-code editor. I selected an edit, report or operation page from the list. Appointed code editors could write code for, e.g. games, timed events or content management systems. Certain disabled people could read PDF content and answer questions in word processing documents.
78. The interpreter kept the passwords away from users unless a user requested the password. I included a password field in the State Saving Interpreter Web Service. The password field showed bullets (black circles) when the user pressed keys in the web page field. The interpreter tested for the command before running it. The user could save the password using jQuery.

79.  I could select and abolish particular asserted rules.  For example, I abolished all predicates with a specific name and arity.  I could also abolish all predicates with a particular body.  In addition, I could add predicates with these attributes.  Finally, I could collect and edit parts of predicates.
80.  I found that the successful result was [[]], not [].  I bagged (selected) database results that met certain conditions.  I found that all items were not failures.  I found searches, permutations and set-theoretical sets of items.  I searched within domains for items.

*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"c\"],[\"c\",\"mannerisms\"],[\"mannerisms\",\"attached\"],[\"attached\",\"campaign\"]]),b_alg([[[],\"c\"],[\"c\",\"mannerisms\"],[\"mannerisms\",\"attached\"],[\"attached\",\"campaign\"]],a),bb_alg([[\"c\",\"mannerisms\"],[\"mannerisms\",\"attached\"],[\"attached\",\"campaign\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[],v],\"c\"]]),b_alg([[[[],v],\"c\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"c\"],[\"c\",\"conjoiner\"],[\"conjoiner\",\"vanishing\"]]),b_alg([[[],\"c\"],[\"c\",\"conjoiner\"],[\"conjoiner\",\"vanishing\"]],a),bb_alg([[\"c\",\"conjoiner\"],[\"conjoiner\",\"vanishing\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"user\"],[\"user\",\"backed\"],[\"backed\",\"monos\"]]),b_alg([[[],\"user\"],[\"user\",\"backed\"],[\"backed\",\"monos\"]],a),bb_alg([[\"user\",\"backed\"],[\"backed\",\"monos\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"lucian\"],[\"lucian\",\"pawing\"],[\"pawing\",\"offerings\"]]),b_alg([[[],\"lucian\"],[\"lucian\",\"pawing\"],[\"pawing\",\"offerings\"]],a),bb_alg([[\"lucian\",\"pawing\"],[\"pawing\",\"offerings\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"lucian\"],[\"lucian\",\"incrementally\"],[\"incrementally\",\"interestingness\"],[\"interestingness\",\"os\"]]),b_alg([[[],\"lucian\"],[\"lucian\",\"incrementally\"],[\"incrementally\",\"interestingness\"],[\"interestingness\",\"os\"]],a),bb_alg([[\"lucian\",\"incrementally\"],[\"incrementally\",\"interestingness\"],[\"interestingness\",\"os\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[],n],\"ssi\"],[\"ssi\",\"activating\"],[\"activating\",\"deployment\"]]),b_alg([[[[],n],\"ssi\"],[\"ssi\",\"activating\"],[\"activating\",\"deployment\"]],a),bb_alg([[\"ssi\",\"activating\"],[\"activating\",\"deployment\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[],n],\"ssi\"],[\"ssi\",\"safety\"],[\"safety\",\"npackage\"]]),b_alg([[[[],n],\"ssi\"],[\"ssi\",\"safety\"],[\"safety\",\"npackage\"]],a),bb_alg([[\"ssi\",\"safety\"],[\"safety\",\"npackage\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"user\"],[\"user\",\"navigated\"],[\"navigated\",\"pauses\"]]),b_alg([[[],\"user\"],[\"user\",\"navigated\"],[\"navigated\",\"pauses\"]],a),bb_alg([[\"user\",\"navigated\"],[\"navigated\",\"pauses\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"ssi\"],[\"ssi\",\"honesty\"],[\"honesty\",\"breastoned\"]]),b_alg([[[],\"ssi\"],[\"ssi\",\"honesty\"],[\"honesty\",\"breastoned\"]],a),bb_alg([[\"ssi\",\"honesty\"],[\"honesty\",\"breastoned\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"lucian\"],[\"lucian\",\"dendrite\"],[\"dendrite\",\"likeness\"],[\"likeness\",\"enwrapped\"]]),b_alg([[[],\"lucian\"],[\"lucian\",\"dendrite\"],[\"dendrite\",\"likeness\"],[\"likeness\",\"enwrapped\"]],a),bb_alg([[\"lucian\",\"dendrite\"],[\"dendrite\",\"likeness\"],[\"likeness\",\"enwrapped\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[],v],\"user\"]]),b_alg([[[[],v],\"user\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"converted\"],[\"converted\",\"pick\"],[\"pick\",\"muscles\"]]),b_alg([[[],\"converted\"],[\"converted\",\"pick\"],[\"pick\",\"muscles\"]],a),bb_alg([[\"converted\",\"pick\"],[\"pick\",\"muscles\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[[],v],a],\"user\"]]),b_alg([[[[[],v],a],\"user\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[[],v],a],\"user\"]]),b_alg([[[[[],v],a],\"user\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[],v],\"user\"]]),b_alg([[[[],v],\"user\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"lucian\"],[\"lucian\",\"takers\"],[\"takers\",\"apparatus\"]]),b_alg([[[],\"lucian\"],[\"lucian\",\"takers\"],[\"takers\",\"apparatus\"]],a),bb_alg([[\"lucian\",\"takers\"],[\"takers\",\"apparatus\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[[],v],a],\"lucian\"]]),b_alg([[[[[],v],a],\"lucian\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[],v],\"lucian\"]]),b_alg([[[[],v],\"lucian\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"prolog\"],[\"prolog\",\"harnesses\"],[\"harnesses\",\"persuading\"],[\"persuading\",\"physical\"]]),b_alg([[[],\"prolog\"],[\"prolog\",\"harnesses\"],[\"harnesses\",\"persuading\"],[\"persuading\",\"physical\"]],a),bb_alg([[\"prolog\",\"harnesses\"],[\"harnesses\",\"persuading\"],[\"persuading\",\"physical\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"user\"],[\"user\",\"reformulation\"],[\"reformulation\",\"material\"]]),b_alg([[[],\"user\"],[\"user\",\"reformulation\"],[\"reformulation\",\"material\"]],a),bb_alg([[\"user\",\"reformulation\"],[\"reformulation\",\"material\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[[],v],a],\"user\"]]),b_alg([[[[[],v],a],\"user\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"lucian\"],[\"lucian\",\"rush\"],[\"rush\",\"fac\"]]),b_alg([[[],\"lucian\"],[\"lucian\",\"rush\"],[\"rush\",\"fac\"]],a),bb_alg([[\"lucian\",\"rush\"],[\"rush\",\"fac\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[[],v],a],\"lucian\"]]),b_alg([[[[[],v],a],\"lucian\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[],n],\"converted\"],[\"converted\",\"satisfactorily\"],[\"satisfactorily\",\"surrounded\"]]),b_alg([[[[],n],\"converted\"],[\"converted\",\"satisfactorily\"],[\"satisfactorily\",\"surrounded\"]],a),bb_alg([[\"converted\",\"satisfactorily\"],[\"satisfactorily\",\"surrounded\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[],\"prolog\"],[\"prolog\",\"produces\"],[\"produces\",\"ai\"]]),b_alg([[[],\"prolog\"],[\"prolog\",\"produces\"],[\"produces\",\"ai\"]],a),bb_alg([[\"prolog\",\"produces\"],[\"produces\",\"ai\"]])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[],v],\"run\"]]),b_alg([[[[],v],\"run\"]],a),bb_alg([])],[*,\"Lucian Prolog was SSI, which the user converted to C to run\",a_alg([[[[[],v],a],\"prolog\"]]),b_alg([[[[[],v],a],\"prolog\"]],a),bb_alg([])]]
[]
[1mtrue.[0m


noprotocol.


"]