["Green, L 2024, <i>Immortality 19</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Immortality 19

1. I wrote on immortality using radical perspectives in logical possibilities that interested people and were necessary. I wrote more pieces for more information. I wrote an algorithm that composed random, spiritually exciting texts. These suggested uses for computer science from the philosopher's life. I wrote on text, test, file and documentation perspectives for normativity and related to perspectives, writing, programming and induction.
2. I encouraged people to choose themselves in immortality. I wrote details for details. For example, when selecting people to ask to participate, I considered their interests and whether they would benefit. I might choose people with similar interests or who would fit the organisation. For example, they would be interested in computer science, philosophy, and spirituality.
3. I could write logically about immortality, which was the basis for future work and discoveries. I claimed that algorithms were imaginative enough to be the form of knowledge in immortality. First, they determined that the idea was valuable and well-known. Then, they logically explored the idea. Finally, I introduced the unknown to test for compatibility, such as a program that reads my mind and offers corrections to my ideas without any warning.
4. I worked on the plan for the school during my career in immortality. I aimed for conclusions like a vector. First, I wrote the reusable connection. Then, I connected it to other parts to form a whole part. For example, I decided to become a founder of a philosophy school.
5. I wrote features simply in immortality. I wrote more and more drafts until the work was perfect. First, I wrote the algorithm simply and did this to get the recursive structure correct. Second, I wrote the second draft, which included the features. Finally, I wrote an optimised version of the algorithm.
6. I claimed I was not unusual because immortality was more natural and happy. I wrote the algorithm. I wrote the predicate head. I wrote the predicate body. I noted anything unusual.

7. I helped the person to the highest-quality thoughts (I protected top-level with working choice-points) in immortality. I wrote and compared the algorithm with the times. I rewrote if-then in Prolog in separate clauses, improving choice-point performance. I did this while writing a Prolog to C converter, which did. I posted about rewriting if-then and implemented it in my interpreter.
8. I wrote a rich database as I progressed in immortality. Algorithms properly covered all relevant ideas. I wrote the idea. I thought of an idea that covered it. This idea was the correct algorithm.
9. I used reductions in neuronetworks. Algorithms thoroughly examined logic with no flaws. I checked the logic of the sentence. I reduced the repeating structures to a pattern. I wrote the sentence, \"I found the cross-intersection in the house\".
10. I arrived at conclusions more quickly in immortality. I did this by creating reductions in neuronetworks. I trained the neuronetwork with reduced data for more intelligent decisions. I wrote the algorithm that reduced the data. Then, I trained the neuronetwork with it.
11. I reduced the repeating pattern to its shortest form, which was easier to analyse in immortality. Then, I produced the perfect expression with the algorithm that reduced the data. Then, I transformed the repeating pattern into an algorithm. Alternatively, I converted the repeating pattern into an operating system. Or, I altered the repeating pattern into a microprocessor.
12. And-implication, discovered in immortality, was correct and syntactical. The algorithms were logical. The algorithms used and-implication (implication with the logic table for and). I wrote if-then as separate clauses and displayed it as if-then in trace mode. This decision maintained correctness while preserving the syntax.
13. Algorithms in immortality contain steps. For example, I worked in the stream class. First, I wrote a sentence describing what the algorithm did. Then, I wrote the type statement. Finally, I wrote the first and final drafts of the algorithm.
14. I thought positively about becoming immortal. I simplified the design, eliminating bugs. I removed the steps. I shortened sentences. I simplified the data and logical structure of the algorithm.
15. I got more and more intelligent in immortality. I redrafted the algorithm. I identified the algorithm. I found where I had reached. I ordered the variables.
16. I thought perfectly correctly in immortality. I simplified the algorithm by finding the corrections. I found unnecessarily repeated variables. I found unnecessary predicates. I found excessive clauses.
17. I wrote the simple algorithm in immortality. I simplified the algorithm. I made the corrections. I listed the possible errors. I found any errors of these types.  
18. I upgraded algorithms in immortality. I found better, more specific features of algorithms. For example, I changed from labelled lists to curly brackets around types. I found the fully featured algorithm to find a reduced list from repeating data. In addition, I found the fully featured algorithm to generate an algorithm from a reduced list.
19. I wrote the chain of free variables and simplified the algorithm in immortality. If there was no value for A, B was left alone. I read B=A. I read that A had no value. So I left B undefined (as A).
20. I found missing variables in immortality. If the programmer mentioned a variable, it was equal to a value. In B=1, B=A, the result was A=1.  If B=A, B was left equalling A. If there were a conflict, then the result would be false.
21. I kept away from needless cycles in immortality. I rewrote the equals4 command to allow for cyclical data structures. I detected cycles, for example, in A=[A]. The programmer had written this structure as a cycle. If the algorithm evaluated it, it would be false unless A was undefined.
22. I became suspicious of infinite loops in immortality. When A=[A], A returned this value. If a cycle was present and the user switched on the \"occurs check\" flag, the command would fail. The occurs check verified whether one variable was equal to an expression containing itself. If one variable on one side that occurred in a command had a term with that variable on the other side, the command would fail.

23. Disconnected statements or sets of statements that were arguably unused, such as some verifications, were deleted in optimisation, an exercise in immortality. The programmer connected the algorithmic steps. I wrote A=1. I wrote B is A+1. The second command referred to a variable from the previous command.
24. The immortal revealed that the problem of if-then in Prolog was finished. I converted if-then to multiple clauses, i.e. <test1:-(a1(1)->b1;c1). a1(1). b1. c1.> to <test2:-a2(1,R),d2(R).   a2(1,true):-!. a2(_,false). d2(true):-b2,!.  d2(false):-c2. b2. c2.>. This conversion prevented cuts from destroying choice points when if-then was used. Multiple clauses created choice points where necessary, which the interpreter could cut properly.
25. I expanded \"or\" to explicitly include \"b\" in (a;b) if necessary in immortality. The \"or\" command, (a;b), was converted to (a->true;b). The algorithm converted the syntax (a->b;c) first to avoid converting (b;c) to this format. \"Or\" was converted, otherwise, only the first value in (a;b), \"a\", was given. The form (a->true;b) was usually used and was converted into multiple clauses, so (a;b) was rare but still processed as described.
26. The algorithm converted if-then statements with true or false antecedents into hierarchical clauses in immortality. Rather than programmers converting nested if-then into multiple clauses if reification was detected, if-then only tested for the truth of the antecedent, not Output in a(Input, Output) where Output = 1,2,3 etc. If-then would test whether Output = 1,2,3 separately. In this sense, the unneeded reification referred to was Output = 1,2,3, not Output = true or false. The output couldn't equal 1, 2 or 3 because antecedents could only be true or false unless the programmer used an explicit case statement.
27. I only performed needed computations in immortality. I didn't tuck in reused reification list decomposition and building because the programmer would have already tucked them in (see previous paragraph). For example, in (a(1, O1), O1=[O2, O3], O4=[2, O3],(O4=[2,1]->b;c)), if-then started after reification list decomposition and building. The algorithm would group and tuck in any repeated processing. Only O4=[2,1] needed to be the antecedent.
28. Immortality only needed simple tasks. For simplicity, I didn't need to merge (a->b;(c->d;e)) to a single set of clauses if there was one type of antecedent.  I didn't need to merge to a single set of clauses because the if-then clause was already hierarchical, and the multiple clauses would be too. The interpreter was more straightforward without this additional feature. Without an additional case command, displaying the single clauses as nested if-then statements would be too complicated.
29. Each possibility, including failure, must be accounted for in immortality. Even a C-style case statement would be in the form in the previous paragraph so that the algorithm would convert it to hierarchical clauses. In the case of a case statement with conditions with different variables, the algorithm would convert it to hierarchical clauses. For example, (a(1, R, O1, O2),(O3=2->b;(O4=3->c;d))) would be converted to a hierarchical, not a single set of clauses because the antecedents contain different variables, O3 and O4. Whether or not the converter used a single or multiple set of clauses, the reified false result before the antecedent would need to be processed.
30. I saved time by converting if-then clauses properly, preserving choice-points in immortality. One could only have a single set of clauses with nested if-then statements if the algorithm tested a single variable's value or a predicate's configuration of values. For example, (a(1,R,O1,O2),((O1=1,O2=1)->b;((O1=1,O2=2)->c;d))) converted to <test3:-a(1,O1,O2),d2(O1,O2). d2(1,1):-b2,!. d2(1,2):-c2. b2. c2.>  Groups of configurations with the same result, writing the d2 clauses in upper triangular form and failure all had to be considered. The programmer should take care with d2 clauses in the upper triangular form that logical configurations are correct.
31. A mixture of a single set of clauses testing a set of variables and multiple sets of clauses testing further computations were necessary for immortality. One could combine single and hierarchical clauses when the algorithm tested a mixture of single variable values and other variables. For example, in (a(1,R,O1,O2),((O1=1,O2=1)->b;((O1=2,O3=3)->c;d))), O2=1 and O3=3 were deleted because they were unnecessary. Then, the conversion would be similar to that in the previous paragraph. If disjunction was needed, the algorithm handled it like if-then.
32. Immortality edited simple code with effective results. For example, if a=1,b=1 or a=1,b=2, the algorithm could test them as d2(1,1) and d2(1,2) or two levels of multiple sets of clauses. The first choice is more straightforward and preferable. The traced code could display the more straightforward if-then clauses in these cases. The interpreter can debug, modify and reconvert the if-then clause on interpretation.
33. I expanded and grouped disjunction and conjunction in immortality. I handled nested disjunction. I could convert (a;b;c). I could convert (a->O2=1; O2=2) before an antecedent. I could write a phi statement (O1=[_, O2]->true; O1=O2).
34. I introduced necessary commands in programming languages in immortality. To display case-style multiple clauses in trace mode and for the sake of simplicity in debugging, a case command that converted into a single set of clauses should be introduced into Prolog. For example, (a(1,R,O1,O2),((O1=1,O2=1)->b;((O1=1,O2=2)->c;d))) could be rewritten (a(1,R,O1,O2),case([O1,O2],[[[1,1],b],[[1,2],c],[[_,_],d]])). I debugged top-level and lists. I did this by properly converting if-then clauses to sets of clauses and garbage-collecting lists.

From Immortality 1.6.4

35. The immortal avoided the infinite loop from a cyclical data structure, causing an error in the algorithm. When I turned occurs check on, A=[A] (a cyclical data structure in equals4) would fail. The complexity of this algorithm was quadratic (x^2). I compared each item on one side with each item in the corresponding item on the other. If it occurred again, equals4 would fail.
36. The immortal simplified transitive pattern matching, but could also use copy_term to keep variables undefined. A different version of equals4 could define A as B, not empty. I could create a tree, such as A = B, B = C, B = D and C = E. In this, A = B, B = C, C = D, and D = E. This feature allowed append(A,[],[1,2,3]), which depended on statements such as A = B in backtracking.
37. The immortal used the undefined value to swallow or unify with variables with any value. I used copy_term to preserve undefined variables. In A = _, A = B, B = 1, writeln(A), the result was A = B and B = 1. In A = _, copy_term(A, B), B = 1, writeln(A), A was written as _.  In this, copy_term prevented A from being unified with 1.
38. An immortal could optimise reused code. I optimised and merged similar structures. For example, I moved reused code for put_item_n (which replaced item n in a list with a value) to a common area. This reuse simplified editing the code. Also, multiple algorithms could use the code.
39. The immortal simplified the idea. First, I determined whether I needed a bug fix, given the final draft. Then, I tested with and without the bug fix in the last version. If it made no difference or worked without it, I considered removing the unnecessary bug fix. Otherwise, I kept it after testing all cases.
40. The immortal found the version of the code with the least unnecessary changes. Next, I tested combinations of changes to an algorithm. I found all the possible changes. Finally, I tested whether the algorithm always worked with all combinations of these changes. If it did, then I kept the changes.
41. The immortal touched up the texts for easier connections. I took care of problems centrally. I worked with the last working version of the code, which used the latest versions of supporting repositories. I tested the algorithm to make sure it worked. I assumed the packages it used were working but tested them to ensure.
42. The immortal tested the code section by section. First, I found whether a section of the code worked top-down. Then, I wrote the success or failure of a section of the code. Next, I tested whether the section worked with the computation result. Finally, I tested whether the algorithm worked.
43. The immortal added to the code and bug-checked it. Then, I tested each section with simple data. Then, I tested each feature of the algorithm, one at a time. Then, I wrote examples of each part of the code. Finally, I wrote more examples with which the code could work.
44. The immortal simulated programming help at each stage. I ensured there was a single copy of a predicate, not duplicates. I listed the predicate by name and arity with listing(file_search_path(_,_)). or by name with listing(file_search_path).  I checked whether there were any duplicates. I deleted them, checking that they were not loaded elsewhere; otherwise, I loaded the single instances.
45. The immortal touched up the texts for easier connections. I found the link. I found the other connections. I touched up the text so that it was more apparent. I wrote the connection to the next paragraph in the text.
46. The immortal simulated programming help at each stage. The kinder student knew how and what to program. Programming was normal, and people could compare their decisions with its logic. The algorithm asked me how to program. I specified an algorithm and did it using mind reading or sleep.
47. The immortal did ask the search engine questions. The kinder student knew how and what to program. He could read and write many words. He could answer simple programming questions with help. The issues were memory and abstract memory.
48. The immortal had the mental age of an adult. The kinder student could read and write many words. He could recognise spoken words and change these to written words. He enjoyed primary school philosophy, in particular logic, grammar and induction. He could program using symbols and physiologically break a word's spelling down from speech.
49. The immortal could read advanced knowledge. The kinder student could answer simple programming questions with help. She was taught differentiation in calculus. She could transfer this knowledge to a computer program. She could debug and optimise the Prolog program.
50. The immortal had a research assistant to help with abstract images. The kinder student's issues were memory and abstract memory. However, she could remember by rote or visual, backwards, skipping memory exercises. Also, she could make a model and use it to answer questions and use abstract memory to program.
51. The immortal checked each decision with the algorithm, working from first principles if it was down. Programming became expected, and people could compare their choices with its logic. Anything was possible. The person could fly around in a pixel in a simulation. Programming offered a simple method of better examining and thinking logically about ideas.
52. The immortal taught the computer to program algorithm finders. The algorithm asked me how to program. I instructed it to ask for input. I told it the formula for a computer program. It worked out the simple interpreter overnight from knowledge about bindings tables, calculations and the logical structure of an algorithm. 
54. The immortal finished off algorithms for philosophies and unwritten philosophies. I specified a program and did it using mind reading or sleep. The algorithm worked out the specification from previous specifications which I had entered. The specification for the algorithm could be a new, modified or joint algorithm. The specification might need an attached set of formulas, which explained if the data was to be monadalised.
55. The immortal preferred expanded algorithms and multiple-level higher-order programming. The algorithm worked out the spec from the previous specs I had entered. The program writer algorithm recognised a phrase that referred to an earlier algorithm. It could draft the algorithm with either knowledge about the words to modify it from a previous program or new knowledge given by the human. The spec had numbers and possibly functional calls to other algorithms.
56. The immortal reused or modified previous algorithms. The algorithm recognised a phrase that referred to an earlier algorithm. It might be \"replace a word\", \"count the frequency of words\", or \"paraphrase the text, preserving formatting\". It then used one of these algorithms as part of a new algorithm. It could produce an error or warning or make necessary modifications.
57. The immortal assessed the academy's gems, algorithms, songs and philosophies. The program finder could use an algorithm as part of a new algorithm. For example, it could spell-check potential paraphrasing synonyms. Or, it could preserve HTML formatting when replacing text. Finally, it could learn new knowledge about its algorithms in its academy with accreditation.
58. The immortal checked the function. I found more extended algorithms. Instead of writing an algorithm that called functions, I wrote an algorithm that wrote an algorithm to do this. It wrote an interpreter for simple test cases, with all possible combinations of commands up to a level. Also, it found missing commands, such as recursion functions.
59. The immortal flagged long or repetitive texts. I found new philosophies. I found the combinations of philosophies. I checked if they inspired new words. I deleted or replaced repeated words, changing them, influenced by the grammar-logic algorithm's output.
60. The immortal could produce algorithms automatically, logging errors and changes. A program finder could have an error or warning or make necessary modifications when needed. For example, it might create a notification when input is ambiguous. It would produce an error if there were a problem producing output. Or, it might self-correct if data was close to the correct format and in a file with a backup.
61. The immortal read the list of warnings or modifications (or ignored them). For example, the program finder might produce a notification when the input is ambiguous. For instance, if the \"types to algorithm\" algorithm could produce brackets instead when given lists (of the same length) or lists when given a single set of brackets, it might create a warning. In the first case, it would make necessary modifications anyway. Given the warning in the second case, it could modify the algorithm, given more information later.
62. The immortal used data structure verification to type-test data structures in Prolog. The program finder might self-correct if the data was close to the correct format. The robot never ended the conversation; he kept thinking with me but reset later. He was also the product, not experiencing the product. The robot experimented with generative simplicity and ensured correctness in Prolog's data structure format.
63. The to-be-immortal found the Time Machine software. With either knowledge about the words to modify an algorithm from a previous program or new knowledge given by the human, the program finder algorithm could draft the algorithm. If the words were ambiguous, missing detail, or unknown, the algorithm would ask the human for assistance. I wrote the press release for immortality with software that allowed women to keep their youthful appearance.
64. The immortal called pedagogy meditation. The specification had numbers and possibly functional calls to other algorithms. All parameters were determined, for example, which part of the essay to paraphrase or that the interpreters should run the same programming language. The time traveller breasoned out an A to stay \"alive\" to the world, and 5*50 As later. Also, the recently departed could be transferred to immortality, found out just when they appeared to die and stay happy.
65. The immortal wrote the Text to Breasonings algorithm and couldn't find a counterpart elsewhere. The specified algorithm could be new, modified or joined. It could be unique, entered by the human. Or, the program could change it with a different configuration from the original. Alternatively, the program could connect two or more algorithms, usually with modifications.
66. The immortal wrote the required input and output in a text file. The specification might need an attached set of formulas, which explained if the data was to be monadalised. \"Monadalisation\" was when the algorithm tested each statement for truth, and then the algorithm tested subsequent statements for truth if the previous one failed. Or, the algorithm tested the following statements for truth due to the previous one being correct. There might be a multiple-clause nested if-then statement, which the user could modify.

66. The immortal encouraged more people to program assignments. I questioned whether the student would want to program more if the Academy was accredited. The teacher gave the student the spec. The facilitator worked on each line and connection with two uses (in breasonings and algorithms). He worked on it, thinking about each conclusion in a high-quality way.
67. The immortal wrote 5 As to prepare students to write essays. The student might want to make connections more if the Academy was accredited. The facilitator worked on two uses in breasonings and algorithms for the lines and links in the essay. The student was inspired by these and wrote his connections. He finished the article, having thought about the synthesis rigorously.
68. The immortal tested for cascading changes needed to code. I tested the predicates individually. Then, I wrote sets of correct input and output for each predicate. Then, I monitored them for required changes. Finally, I tested the predicates' features and error handling.
69. The lyrics reminded the immortal of the topic and could be changed to be more relevant. First, I fixed the predicate in music composer, which omitted spaces in songs. Then, I found the predicate which produced lyrics. Finally, I found the bug which missed spaces. I fixed it and worked on an algorithm that wrote texts (like lyrics) that a writer could interpret as essays on a topic.
70. The immortal labelled and verified data. I created a single choice-point identifier. I wrote the words \"choice-point\" at the start of each choice-point. This phrase delineated choice-points from findall data and other data. I could find, manipulate and delete choice-points using this identifier.
71. The immortal bot produced ideas, and they were breasoned out. I wrote 50 As for mindfulness for the necessary financial benefits from bots in meditation. I noticed the bot earned 50 As in immortality. This achievement was from a degree. The bot could be immortal.
72. The immortal sped up algorithm generation based on their ideas. The founder stated that the Academy was original because of simple algorithms and induction. The algorithms included original interpreters. Also, they had brute-force induction and meta-induction algorithms. Students were encouraged to write philosophies and write algorithms using algorithm writers.
73. The immortal used rules to demonstrate understanding of a topic. I kept copies of unmodified texts and texts with connections for use with Essay Helper, for neuronetworks. This data helped speed up writing, where the student knew the ways of thinking. I entered a text into Essay Helper. The neuronetwork helped produce an essay.
74. The immortal considered the feature, which needed to be as rigorous as C. The student increased her skills with time, writing more and more complicated algorithms. She wrote examples of fundamental ideas and simple algorithms at first. Then, she collected more and more advanced skills, such as associating or copying a variable to another part of the program, or lists of labels for variables and predicates and lists of failed ideas (such as a blue cut, which would have cut future choice points in a predicate but Prolog already did it). She added these to her algorithm generators, finding that the more she wrote, the more possibilities there were.
75. The immortal matched patterns to recursion, avoiding infinite loops. I used the \"types to algorithm\" algorithm to generate grammars. The algorithm could find code from repeating lists. It could be modified to produce grammars instead of code by using special symbols instead of lists. The programmer needed to show care to avoid left-recursive grammars, which the algorithm prevented.
76. The immortal simplified code to expressions. I used the \"types to algorithm\" algorithm to generate list expressions. These could be left as expressions and used to process lists or strings and produce code, grammars or modified list expressions. The \"find lists\" algorithm produced the list expressions. List expressions were less complex than code and included repeating parts for conversion, analysis, reuse and storage.
77. The immortal stored pattern matching code as list expressions. I analysed list expressions. I found whether list expressions recurred, and I could keep them in one place. This analysis entailed parts of list expressions in terms of other parts. It also involved functional calls (intermediate functions that could pass calls).
78. The immortal included list expressions in logic. I reused list expressions. I entered them and found output from the input. List expressions contained symbols that the algorithm could substitute with other values. For example, they had symbols that replaced \"[\" and \"]\" at the start and end of lists.
79. The immortal created a web app using logic and mock-ups. I did this using the \"types to algorithm\" algorithm to process strings. First, I entered the possible list delimiters. Next, I entered possible white space (fill-in) characters. Finally, I entered possible comments and end-of-file characters.
80. The immortal spent less time on development and more time on creativity. I created a web app using logic and web page mock-ups. The algorithm pattern-matched items, producing an algorithm with specific results given a particular input. This web app could be a game, a chatbot, a question-answering algorithm or a translator. This web app could pattern-match strings and lists and, using program finder, find lists from two lists using pattern matching.

"]