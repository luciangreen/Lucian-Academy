["Green, L 2024, <i>Immortality 27</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Immortality 27

1. The immortal tested code in seconds. I wrote the CI/CD tool in C for speed. It could test C code. It had faster infinite loop detection. It ran code converters more quickly.
2. Lucian CI/CD tested each combination of changes to a group of predicates. Lucian CI/CD produced an error if it couldn’t successfully test a group. All tests for predicates were found. All predicate names and arities were printed. Tests were optional, but failure meant the combination failed.
3. The immortal fixed code bottom-up to fix bugs in predicates once dependent parts were repaired. That a called predicate should be tested as part of a group with its calling predicate isn’t necessarily true. If the called predicate calls a predicate that calls the calling predicate or a higher-up predicate in a chain that calls the calling predicate, it is in a loop, and the predicates can be tested together. However, with no loop, the lower predicate should be tried first, and if it is successful, then the upper predicate should be tested, eliminating errors in fixing bugs. If there is a bug in the lower algorithm, it can be fixed. Then, the upper algorithm can be tested successfully, whereas trying the upper one first is problematic because it is dependent on the result of the lower one, which hasn’t been fixed yet.
4. The immortal inserted a negative test that failed on a particular output. The tests for each predicate conducted tests for wanted and against unwanted behaviour. They could test for infinite loops, caused by missing base cases. I tested for extra, uncut results. If there were additional results, I inserted a cut.
5. The immortal wrote Lucian CI/CD tests with a predicate name and possibly data and output variables. If predicates formed parts of loops that didn’t need to be tested, tests for these predicates could be omitted and still pass. There would be a warning if there were missing tests. The predicate names and arities would be printed. The successful and unsuccessful test results would be printed.
6. The immortal wrote about the behaviour of pacemaker predicates. Lucian CI/CD could handle a loop with more than two predicates. The loop could have a second looping call from a different line of the predicate. Or it could call another first predicate. It could handle these loops and group predicates to test accordingly.
7. The immortal could handle complex predicate dependencies arising from mixing old and new versions of the repositories. Lucian CI/CD could take multiple loops from the same predicate. The predicates directly involved in the loops were grouped to test. These groups were at the top of the predicate list. The predicates they called were first in the list.
8. When converted, The immortal could still test other programming languages and data. Lucian CI/CD detected and deleted duplicate predicates. These predicates weren’t needed and could produce erroneous results if not deleted. These deletions didn’t include comments, which could keep identical lines required in different places. Only new comments were held as comments couldn’t be checked as part of the algorithm, eliminating wrong comments being kept.
9. The immortal removed unused main files or main predicates from main_file.txt. I used a main_file.txt, which listed all the main files, main predicates and their arities to test in the repository. All the repositories connected with a change file’s repository were tried this way. If a repository called a predicate from another repository, then this repository might be called once by each repository. The main_file.txt could be changed if there were multiple repositorilets (sic) or multiple main predicates.
10. Lucian CI/CD integrated possible changes to the relevant repositories. Lucian CI/CD tested many predicates together. It found the tests matched the name and arity of the predicates. It tested the predicate, which resulted from the merge algorithm that integrated various changes to these predicates. This merge algorithm used a variant of the diff algorithm to detect changes.
11. Lucian CI/CD could warn of a cyclic dependency. I ran Lucian CI/CD for each repository connected to the first repository. The first repository set included all modified repositories since the last time Lucian CI/CD was successfully run. The repositories connected to the repository were listed in the List Prolog Package Manager’s registry.txt file. This algorithm stopped when there was a cyclic dependency
12. If a predicate failed in Lucian CI/CD, it was only retested if it was part of another combination or main_file.txt test. I only tested a predicate while testing predicates bottom-up once. This fact was a trade-off of testing bottom-up. If a branch was complete, then the following predicate could be tested. Lucian CI/CD returned true when all the predicates were tested.
13. The immortal didn’t rely on comments, etc., from old versions. I always loaded data, comments and tests in files into the new version. Data always came from the new version. Comments always came from the new version, and old ones were deleted. In addition, tests only came from the new version, so they needed to be updated.
14. The immortal could institute a feature that made a positive test mandatory for each predicate. The tests will be loaded for each predicate. The tests were loaded at startup. The tests were needed for each predicate to test whether it worked. It was possible for a predicate set to pass without tests to allow for some predicates to be passed when they are working in confidence, but there is a warning in this case about the predicates and tests having a disparity.
15. The immortal found that predicates were similar to repositories in that a change lower down could affect entities higher up. The predicates needed for other predicates are loaded when a file has been modified. A changed file or changed modification date of a file triggered all files connected with it to be tested. These included the files containing predicates it needs, and that need it. This decision is because the file’s differences may affect the files that call it.
16. The immortal tested for errors, not just failures in algorithms. Tests are run that correspond to a repository’s primary file name, where Lucian CI/CD fails without this file name. If there is no file with this name, Lucian CI/CD gives an error and aborts. The same is true for primary predicates. If a predicate calls a predicate that doesn’t exist, the program will produce an error.

17. The immortal developed a system in Prolog for secure web apps. I included State Saving Interpreter Web Service as a Prolog library. This library enabled Prolog algorithms to be a web app. State Saving Interpreter Web Service converted Prolog algorithms to a List Prolog algorithm and ran it over several pages. Parts of it could be in Prolog or C, with tail recursion optimisation for speed.
18. The immortal demonstrated multimodal append in the lecture. I hypothesised how to implement a top-level and multimodal append version in List Prolog. I reverted to a version of State Saving Interpreter, which supported append as a multimodal predicate. In addition, I eliminated unwanted choice points to implement top-level. Multimodal append could now return multiple solutions at the top level.
19. The immortal stated that the development environment worked better with shorter, simpler predicates. I wrote the algorithm top-down but tested it bottom-up (depth-first post-order) with Lucian CI/CD or higher development speed and accuracy. Or I wrote a plan and filled in the predicates. I tested each predicate, ensuring their results were as expected. When Lucian CI/CD indicated a bug in a predicate, I entered the development environment to fix it.
20. The immortal stated lower predicates than changed predicates couldn’t be automatically passed because they might refer to asserted predicates, meaning these assertions were needed in lower predicates for bottom-up Lucian CI/CD to function correctly. I listed predicates in the touched files and the predicates they called. Instead, I listed all repositories connected to any touched files. I tested the modified predicates above and below. I retested lower predicates.
21. The immortal used predicates to number the items. I numbered the predicates. I identified the predicates as having a unique name and arity. I gave these collections of clauses (a predicate) a unique number. This number started from zero and increased by one for each predicate.
22. The immortal returned to top-down Lucian CI/CD, determined by the main file, not the current file, for most cases (including asserted predicates). I ordered the predicates in bottom-up order. The predicates were numbered. They were ordered by depth-first post-order traversal. They could be renumbered and inspected.
23. As an aside, the immortal renamed sub_term_wa sub_term_with_address. If there was a loop, Lucian CI/CD grouped the predicates. The algorithm traversed the predicate numbers. A future predicate number was recorded if it indicated a loop. This bottom-up version of Lucian CI/CD was only activated if there were no assertz statements in the calling predicates.
24. The immortal only reused test results when the conditions were the same, for example, in main file branches. I tested predicate groups with not yet done tests. I ran the test and recorded the result. I identified that another test wasn’t likely to have the same result because it was run on a different code combination. Therefore, I didn’t necessarily record the old test results.
25. The immortal stated that Lucian CI/CD finished the needed changes by omitting some tests with notifications after assessing the best combination given the tests, for example, after identifying the direction and multidimensional terms. I applied the combinations to new predicates in each group. I discarded it because finding combinations from new predicates was too tricky. However, I found all the combinations and only tried the combinations with content from changed predicates. This process eliminated up to 100% of the tests.
26. The immortal had a cup of coffee after entering the description of the changes needed. If a predicate is unchanged, other changes may affect it. This condition meant I didn’t skip it. In addition, I noticed whether the predicate had different truth behaviour and if changes to it would produce other output. I finished changes to a predicate given an identified direction, creating a new test.
27. The immortal wrote Prolog without choice points outside findall but a Prolog-like syntax. I tested one predicate group (including all its clauses) simultaneously. A predicate’s clauses each have the same test, which the predicate’s clauses are tested on. The test is run with each clause unless a cut is reached, in which case no more clauses are run. Cut deletes choice points within the predicate.
28. The immortal took predicates, which completed tasks from a library. Lucian CI/CD saved updates from successful combinations of current predicates. Each run of tests went from the start, and combinations were tested at each point until a suitable one was found. The same tests from different main files were skipped. Circular and defunct “include” statements were deleted.
29. The immortal borrowed code style but simplified it. Lucian CI/CD tests were loaded for each set of current predicates. If there was no test for a predicate, it could be synthesised by taking input from another predicate and finding the output from the predicate. Dead areas of the predicate or not working clauses could be corrected. This process could create a test from neighbouring predicates.
30. The immortal simplified the predicate based on the required output. The algorithm produced an error if there was no Lucian CI/CD test. This setting was enabled for strict testing. Strict testing tested each line of the predicate. Incorrect or missing outputs were fixed. Extra or unwanted results were eliminated.
31. The immortal explained that if there were more than seven algorithm changes, all the changes were tested as a single combination. Lucian CI/CD tested Prolog bottom-up. The new top-down version required main_file.txt to load the code from a single file and predicate, which solved the problem of predicates not being loaded. The repositories were loaded from the main predicate in the main file, loading all necessary predicates for a test. There were all-or-nothing combinations of up to seven changes per algorithm on testing.
32. The immortal tried combinations of set data to test a random algorithm. Lucian CI/CD detected whether assertz, random, user input or API calls were affecting the predicate. If there was an assertz call, top-down Lucian CI/CD was used. If there were calls to predicates with unpredictable outputs, they were temporarily replaced with single value givers and tested individually. If there was a random predicate, it was tested to give values between A and B.

33. The immortal ran top-down Lucian CI/CD on the most extensive set of dependencies, including a definition and access of an asserted predicate and bottom-up Lucian CI/CD on the rest. I ran all the necessary tests. I ran the tests with bottom-up Lucian CI/CD on each set of current predicates. Lucian CI/CD reset the seven changes for each new set of present predicates. Programmers could test up to seven additions, deletions or alterations per set of predicates.
34. The immortal converted Prolog to findall and foldr and then to C. I logged the predicates tested and the results. Each test included the file name, predicate and test. It also had the consequence of success or failure-a separate algorithm found and deleted unnecessary clauses.
35. The immortal double-checked repositories when new code had been written. If all the tests passed, Lucian CI/CD saved the files. The code was checked bottom-up if the new top-down main predicate tests failed. I ran List Prolog’s tests, including types, open, and open trials. If any tests failed or if I wanted to double-check the code, I ran Lucian CI/CD.
36. The immortal stated that the code identifier recognised the code’s aim (process, search, get or put values or interpreter predicates) and simplified it. I found the best changes across the versions with Lucian CI/CD. To do this, I needed tests for the new predicates. I ran Lucian CI/CD for each version in order, changing the tests as I went. I wrote an algorithm that found the minimal code for a predicate across the versions.
37. The immortal barred entry to writing code unless a test had been written. Lucian CI/CD could give an error on no test, ensuring the code was tested. The test generator ran through the code, providing a base case and one trial before the base case. A moderator checked these tests to ensure they checked each line of code. There could be combinations of lines in which duplicate lines and unnecessary lines of code were deleted.
38. The immortal focused on a predicate with many changes by itself, modularised functions, increased the number of possible changes past seven, and reduced the code by writing ideas about it. I saved repositories processed with Lucian CI/CD as I went. I processed earlier versions of repositories, adding version numbers as I went. Running Lucian CI/CD on one of these old versions and a stable new version gave the desired results. A non-stable version shouldn’t be used because it wouldn’t work, and there was a warning if the number of changes was more than seven for a predicate group.
39. The immortal found each predicate’s calls. I identified a predicate by its name and arity. I listed the predicate’s lines as a state machine. I listed all the predicate calls, their names and arities. I sorted and removed duplicates from this list.
40. The immortal wrote an algorithm to document tests for predicates over time. It is best to run top-down Lucian CI/CD with few changes at a time. This version of Lucian CI/CD was possibly obsolete, only able to deal with up to seven or one large group of changes at a time. Bottom-up Lucian CI/CD was introduced to alleviate this problem so multiple teams could work on changes. The bottom-up version could handle more changes from various groups at a time and was preferred.
41. The immortal stopped the pipeline to make changes. I ran Lucian CI/CD for each group of predicates. I stored and built tests from other strings and terms. There were ontologies of data structures stored as type statements. This setup sped up development and testing.
42. The immortal stated that only predicates affected by a changed predicate needed to be tested. Lucian CI/CD only tried a predicate once. Each calling predicate might affect a called predicate. This state of affairs usually didn’t matter unless assertz was involved. If called predicates weren’t affected by a calling predicate, for example, ones in different repositories, they could be tested by themselves.
43. The immortal manually approved failing data. The old Lucian CI/CD version could set up untestable comments and test data that the algorithm depended on. The new version passed all new comments. It was a contention between keeping all new comments or testing them, possibly labelling testable comments. These testable comments, such as data, could be labelled in a settings file and manually approved by a human.
44. The immortal indicated which files were programming languages other than Prolog. I checked the data files with the old version of Lucian CI/CD. This version of Lucian CI/CD was the last one compatible with programming languages other than Prolog. A testing script that tested the lines of data, or lines in the different programming languages, tested and approved or disapproved of the lines. The user indicated whether to support programming languages other than Prolog in a setting.
45. The immortal attracted the best talent and achieved success. I examined people politically to reward and recognise them. I wrote the A for the person. They worked in the company and experienced their goals. I replaced two words in each argument and algorithm A with critical terms from them.
46. The immortal updated any tests affected by the output of the predicate the test was for. I loaded the tests for each predicate. I prepared to load the tests by writing them before each predicate. I updated the tests when I changed the predicate. I also updated the tests affected by the test.
47. The immortal suggested main files and predicates and their arities when the main file was missing or possibly wrong. The predicates calling predicates are different from touched files. A settings file with a repository’s primary file name is needed to access them. Lucian CI/CD fails without this settings file. Lucian CI/CD complains when it can’t find files.
48. The immortal tested the predicates affected by the changed predicates (their output). I tested all repositories connected to changed files. I tested predicates, predicates that called them and predicates that they called. I made allowances for different dependencies of predicates because of loops. I ran Lucian CI/CD when a file changed on all affected repositories.

49. The immortal was critical of leftover predicates using Lucian CI/CD, so they deleted them. Lucian CI/CD used tests that tested each predicate in the current predicates, not the predicates from which the combinations of changes were taken. I made having tests mandatory. It was a bug to test predicates outside the set of current predicates. With the required tests, no errors remained.
50. The immortal sorted and eliminated duplicate pairs of numbers that made a sum. In the List Prolog to Prolog Converter verify script, I tested that [[n,+],[[v,b],[v,c],[v, a]]] converted to A is B+C. The converter shouldn’t produce “+(B, C, A).\n”. I noted that in “+(B, C, A).\n”, B and C are inputs, and A is the output. A variant of “+” took two and gave each combination of integers that summed to it. 
51. The immortal later tested the List Prolog to Prolog pretty printer by itself. I wrote a List Prolog to Prolog pretty printer back-translation verify script. It worked in the following way:

[‘p2lpconverter.pl’].
[‘pretty_print_lp2p.pl’].
LP=[[[n,a]]],
pp_lp2p0(LP,P),p2lpconverter([string,P],LP).

It gave the following output:

P = \"a.\n\n\",
LP=[[[n,a]]].

In this, the output of the back-translation algorithm is the same as the input.

52. The immortal later tested the List Prolog pretty printer by itself. I wrote a Prolog to List Prolog pretty printer back-translation verification script. It worked in the following way:

['../List-Prolog-to-Prolog-Converter/lp2pconverter.pl'].
[‘pretty_print.pl’].
P=\"a.\n\",p2lpconverter([string,P],LP1),pp0(LP1,LP2),term_to_atom(LP3,LP2),lp2p1(LP3,P).

It gave the following output:

LP1 = LP3, LP3 = [[[n, a]]],
LP2 = \"[\n[[n,a]]\n]\",
P = “a.\n”.

In this, the output of the back-translation algorithm is the same as the input.

53. The immortal preserved the order and formatting of predicates and comments, respectively. I recorded the order of predicates before and after merging to insert them in the correct order in the Lucian CI/CD results. I numbered the predicates before joining. After merging, I inserted these predicates in the same order as the original list of predicates using their numbers. I did this by finding the numbers of returned predicates corresponding to the original predicates’ numbers and inserting the predicates.
54. The immortal had 4*50 As in acting and politics to be a public figure. I grouped loops in Lucian CI/CD using a depth-first search when finding dependencies. I included calls directly on the way to a recursive call in the loop. If two loops recursively called the same predicate, they were stored together. I cleaned the loops up, checking for single instances of predicate numbers.
55. The immortal integrated the predicate search into Lucian CI/CD. I checked that a predicate from another repository was loaded using List Prolog Package Manager (LPPM) when that repository was the main one, producing an error otherwise. When running a repository, I checked all predicates in other repositories were loaded with LPPM. I found whether the algorithm had defined all predicates it called. Otherwise, I found them and loaded them with LPPM. I searched for these predicates by name, arity and type and tested they worked bottom-up.
56. The immortal wrote, so that assessment was different each time. There were 16 models for evaluation per area of study. These models were the main questions. There was one critical analysis question. There were sixteen possible reason sets.
57. The immortal’s job was to write notes. The students’ assessment had high standards. I helped them with the algorithms. It was fun for them. Their seen-as version was remembering a word, thinking of a mathematical answer or applying mathematics to English.
58. The immortal taught the children philosophy in their home. There was accreditation for students at the institution. The institution was any school, company or home. The company had courses to teach its employees to increase the quality of their work. The content needed to connect to their work.
59. The immortal wrote text files to help everyone have information at their fingertips. I accredited work for disabled students. I worked on one to three predicates for intellectually disabled students. I found something that they wanted to do. One wanted files, while the other wanted objects.
60. The immortal asked the student to develop a specification based on their interests. I wrote the questionnaire about philosophy. I asked the students to write an argument or an algorithm on campus. I asked the student to work out the result of an algorithm given a model. Then, they were asked to write an algorithm given a specification.
61. The immortal found out what the client’s requirements were. I wrote 4*50 As for regular word-of-mouth appraisals. I wrote preparation for the launch, events and close of a centre. The centre was accredited. The teacher was selected.
62. The immortal thought it was the most fun thought and that anything was possible because of it. I chose, explained and wrote a program for a person. The person helped choose a part of the topic they were interested in. We discussed and mind-mapped the topic, hinting at algorithms at each point. The person took the initiative to write an algorithm that required the visualisation of data structures and helped someone else write it.
63. The immortal mirrored the details grid from a prestigious institution’s assignment. I found students after lectures and talked. I met and went to a café to discuss philosophy. I showed them an app or a website that demonstrated my algorithm, and they wrote their ideas down about it. I put up posters, and they came at the same time each week to learn about more algorithms.
64. The immortal wrote 6*4*50 As to teach. I sold my books in the city. I hired a place near a train station and set up a table to sell books to the public. They were printed books about immortality, time travel or philosophy. They could become with-it about Text-to-Breasonings by developing As and helping others.
65. The immortal gave the website address for people to join the book club. I bought and sold books. I wrote the book. I bought published versions of the book. I sold the book for a slight margin.

66. The immortal kept the folio of development of the package. The four levels of the Lucian CI/CD weblog corresponded to the current version of the existing repository. The first level was API changes or changes to a programming language's syntax. The second level was new features. The third and fourth levels were bug fixes and progress towards bug fixes.
67. The immortal monitored the building for structural problems. I earned money from property. I bought the property. I rented it to either tenants or a meditation teacher for a discount. I renovated and sold it.
68. The immortal's job required medical and business knowledge. My job was in aged care. I undertook training. I applied and earned the position. I contributed money to bills and property.
69. The immortal helped the student with the algorithm. I discussed the requirements. I helped them mind map the problem. I helped them visualise it. I discussed the frequently asked questions.
70. The immortal explained the model solution. I replaced the algorithm with the answer. I inserted missing or replaced incorrect lines. I helped the student understand the solution entirely. Where the movie had a working script, academia had a viable product and research.
71. The immortal drafted the algorithm idea and filled in the code. I helped with one predicate at a time. I recommended functional decomposition. I produced a simple version. I added to it, preferring recursion to findall.
72. The immortal combined select and subterm with the address to find the complement of part of a multidimensional list. I searched for alternative solutions. I changed the method. I converted an answer from another programming language. I wrote an advanced command.
73. The immortal inserted a needed label. I gave a hint about the command and its arguments, not the order of its arguments. I shared tips about the order of items in a list. I also have hints about the order of items in a multidimensional list. I did the work to eliminate obsolete elements.
74. The immortal designed the computer science report. I explained and confirmed understanding of the code. I explained each feature of the code. I found and corrected bugs. I checked that the student could reproduce a similar example and write a self-test for students to test each other.
75. The immortal used software for free, and the employees wrote pedagogical algorithms. I modified the Vetusia game engine to pass arguments with a login web page. It used a backend server, where the algorithm was hidden from the web page. The user entered their login credentials, which were encrypted and checked against the database. The payment side was out of their hands.
76. The immortal completed the points as part of their job. I wrote the enrolment engine. After the user logged in, the Prolog web server displayed the list of courses in their course. They started working on a subject. They sent in their work and received feedback.
77. The immortal increased the value of the product. I processed the payment with 40*4*50 high distinctions for high-powered refunds. I needed an extended key to protect the buyer. I covered the buyer, the database and myself with cybersecurity policies. If the customer was unsatisfied, they could have credit on their professional development loan.
78. The immortal sped up each algorithm. I wrote autoparaphrasing and autobreasoning algorithms (without input) to work faster. The first algorithm produced the list of synonyms. The first algorithm produced the list of breasonings. I used faster commands, such as maplist, multithreading and C, to make them work faster.
79. The immortal wrote the interpreter in C, treating memory as an operating system would. I sped up the interpreter. If an algorithm didn't need multiple predicates, I simplified it. I used maplist and multithreading where possible in the interpreter. I worked out which parts of the algorithm wouldn't be used at compilation and with particular input and deleted them.
80. The immortal converted each complex command to C. I converted maplist to C. In C, maplist was a loop. I also converted foldl and foldr to C. Foldr inserted reverse into foldl. Foldl applied command(s) recursively to data.

"]