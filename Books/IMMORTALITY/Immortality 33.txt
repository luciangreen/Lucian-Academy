["Green, L 2024, <i>Immortality 33</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Immortality 33

1. The immortal stored data from a particular date together. I supported file date data in Lucian CI/CD tests. I retrieved the data from a test. I checked other data items matched this in part. For example, the date may be concatenated to a file name.
2. The immortal found recurring items in term atoms in testing. I tested types in Lucian CI/CD. This feature was helpful for user input, random data, and API output. It was not recommended with dynamic predicate data converted to variables or tested in a group of predicates. I could convert some parts of types to variables that repeat.
3. The immortal simplified algorithm to loops and then to assembly code, which could run on any system (using universal assembly code). I found the list using an algorithm. I achieved this using mathematical types (for example, a_0,...,a_n), comparative or ordered mathematical values, simple data or taking from nearby variables. I was determined not to correct findall with multiple predicates until creating the \"collect and process\" optimisation, simplifying findall as much as possible. I compressed algorithms into valuable parts, only collecting the needed parts and possibly substituting them back later. I rewrote the algorithm that used dynamic predicates in findall to use predicates.
4. The immortal cut off the recursive types after several levels, removing their recursiveness. I found the recursive types with an algorithm. I found the types within bracketed types. I found multiple possible types of an item. I found recursive (repeating) types and represented them as loops, possibly with the list processing pipes symbol.
5. The immortal started bottom-up, collecting like types. I found lists and recursive types. In addition to bracketed lists, I found repeating lists with Program Finder with Types (PFT). If an intermediate level repeated, I made it recursive. If the last part of a list is repeated, I use the pipe symbol.
6. The immortal found whether the algorithm functioned properly by finding data and refactoring it with Lucian CI/CD. I generated data using types. I gave repeating variables the same values. I found three-level recursive parts with different commands if the data was an algorithm. Types could be strings in term atoms.
7. The immortal created constants when writing the algorithm and found obsolete parts of data. I found the algorithm using types. The types contained variables and variables in term atoms. The variables were mathematical types (for example, a_0,...,a_n), and constants may be included. These may be initial counter-values.
8. The immortal found and solved errors in Lucian CI/CD and the interpreter. I supported program error codes in Lucian CI/CD tests. I tested for missing dependencies, files not in folders in the repositories folder, too few items to find combinations from, reaching the interpreter's time limit, failed tests, missing clauses from main_file.txt and a missing main_file.txt in Lucian CI/CD. I tested for missing predicates, badly formed grammars, uninstantiated variables and wrong types in interpreters. I checked that error codes from algorithms were correctly handled.
9. The immortal could only reorder clauses in Combination Algorithm Writer (CAW). Both clauses of the predicate were kept when it passed the tests. When there was one test per clause, they were kept. If there was one test and the predicate was recursive, both of its clauses were kept if the predicate passed. Predicates with multiple base cases and other clauses may have clauses removed if tests didn't test these clauses.
10. The immortal added or changed to lines from the shortest correct combination of the current and previous versions. Lines would only be added from the earlier version if needed to construct the shortest version that satisfied the test. An example of a line being added is B=2 being added to A=1 if it corrected the previous version. An example of a predicate being added is \"b(2).\" if it corrected a findall result in the last version. The result of these is the shortest possible correct result.
11. The immortal could only shorten mathematical formulas or change variables in the predicate header using PFT or doing it manually. Lines would only be removed from the previous version if needed to construct the shortest version that satisfied the test. An example of a line being removed is B=2 being removed from A=1, B=2 if it corrected the previous version. An example of a predicate being removed is \"c(3).\" being removed from \"a(1). b(2). c(3).\" if it corrected a findall result in the previous version. Lucian CI/CD is designed to keep only the first item in a list of commands or allow no predicate body, either of which may be the shortest possible correct result.
12. The immortal included references to the documentation in the version number. I tested multiple repositories in Lucian CI/CD. These repositories needed main_file.txt in their main folder, at least with \"[]\" to register their main predicates. Later, I automatically detected the main predicates and tests, warning of disconnected predicate islands. I tested related repositories together, creating an \"overall\" version number or set of connections between supported version numbers.
13. The immortal added \"include\" references to used files. I tested multiple repositories with no main predicates (but which were used by other repositories). I redrafted and simplified reused code, preparing it for inclusion in a neuronetwork. I asked for connections between sentences and connective algorithms. I deleted \"include\" references to unused files.
14. The immortal explained the file names in main_file.txt weren't used but were reference only. I tested different contents of main_file.txt (in each repository) in Lucian CI/CD. For example, I tested a/1 and b/1 in repository1 and c/1 and d/1 in repository2 from their main_file.txt files. Any predicate connected to these main predicates could be tested through \"include\" links, including those in other files and subfolders. A list of tests procured from the interpreter could be placed in a file and tested.
15. The immortal refactored one predicate with its dependencies at a time, or all at once, made changes on failure and tried again. I tested combinations of one predicate (meaning just one predicate) per file (meaning in one file). Given the number of items to find combinations from was limited where these combinations would have been between the clauses and lines, I found the predicate was verified, not changed. The \"i\" (verified) and \"d\" (changed) values in the verify script were unused because Lucian CI/CD's behaviour depended on the number of items to find combinations from. I lifted this limit to allow Lucian CI/CD to (find combinations of clauses and lines and) change the code.
16. The immortal said Lucian CI/CD faced the same problem of duplicate listings of predicates as Prolog because of the way it loaded files and that this should be fixed. I tested combinations of two predicates per (one) file. If one of these was the main predicate and called the other, then tests would determine the correct combination of their clauses and lines. If a predicate was not called or mentioned, then it would be omitted. This rule applied to both predicates.

17. The immortal contracted the three predicates to use less code or work as a base case state machine. I tested combinations of three predicates per file with Lucian CI/CD. The kinds of algorithms that assembly language supported were compilers, one predicate call of choice points in a findall clause, and algorithms that could be converted to long form. I held items in one place while processing indices and produced intermediate representation from Prolog (with optimisations for Prolog) that could be converted to assembly code and converted to assembly code for a variety of processors (with optimisations for processors). The kinds of changes that Lucian CI/CD made were part of the intermediate representation.
18. The immortal wrote a Lucian CI/CD plug-in that converted findalls to loops. I tested combinations of three predicates per two files with Lucian CI/CD. I avoided choice points in the long-form predicate by writing in such a way as to eliminate the need for an interpreter. Where possible, I converted choice points in findall to loops, including nested findalls.
19. The immortal tested combinations of two predicates per file with Lucian CI/CD. Every loop had the zero test as a base case. I stored the data being recursed elsewhere. Or, I worked out results during run time, stopping when I found the answer. I recursed through the indices, stopping at zero.
20. The immortal combined foldr(append) and foldr(string_concat) into one assembly macro. I tested combinations of three predicates per file with Lucian CI/CD. I wrote native assembly code for predicates, such as foldr(append), which had two loops. I explained that findall looped through items 1-n of members of a list. Or foldr might loop through lists and append them (not storing their data elsewhere, only afterwards).
21. The immortal deleted the duplicates and assembled the same types. I assumed Lucian CI/CD would work with more than three predicates with the same name and arity. I did a spot check with ten clauses. If these worked, I assumed Lucian CI/CD worked. I also checked that findall, maplist and foldr worked with ten solutions.
22. The immortal redrafted end end_nested_findall.pl in SSI to simplify the algorithm. I tested the limitation of the predicates available with Prolog to List Prolog. I made sure that the converters worked with the same commands. Various commands are needed to cover those needed in Lucian CI/CD. If the converters supported these commands, they could be run in the interpreter.
23. The immortal relied on the interpreter if the dynamic predicate couldn’t be predicted. I wrote “:-include,” “findall,” and a custom predicate name in the Prolog converter. I customised the converter to recognise specific dynamic predicate names (in xyf, xfy, or fxy format). I sped up the converter by removing duplicate clauses and differentiating identical tokens. I partially evaluated dynamic predicate names (possibly inventing them if known but unnamed) with the compiler to speed them up.
24. The immortal introduced a Lucian CI/CD plug-in that used CAW, PFT or a neuronetwork to find the right combination of tokens. I tested combinations of lines in Lucian CI/CD. After discovering Lucian CI/CD ran faster with combinations of lines when compiled, I considered breaking lines into tokens to find combinations. I found up to the same item with diff instead of returning that all the remaining items were changed. By breaking lines into tokens, I could change around arguments, list items and higher-order commands.
25. The immortal tried testing ten files and larger sets of repositories in Lucian CI/CD. I tested one, two, or three files in Lucian CI/CD. I notified users that the “toy” dependencies in the verification script were in the List Prolog Package Manager (LPPM) registry and that these entries’ structures influenced the way different tests worked. If repository “x” was mentioned but not included, there may be an error. The tests may work, but there may be an overall failure.
26. The immortal abbreviated predicate names. I included and gave tests for different predicates in Lucian CI/CD. I listed the predicates and their possible modes. I found their specs from their types and the interpreter. I tested them in Lucian CI/CD.
27. The immortal invented new characters to represent programming ideas. I tested changes in calls’ values from other statements or their arguments. I discovered reusing shorter calls to foldr without 0 or [] in different algorithms. I found the minimum solution that worked, considering the required result. I applied minimalism to pedagogy, reusing short algorithms and arguments.
28. The immortal found methods to operate on binary numbers. I reused code to add in assembly code, which I converted to binary. I wrote an algorithm to add two numbers, which I converted to assembly code.
29. The immortal found binary multiplication. I reused code to multiply in assembly code. I pictured multiplying using long multiplication. I looked up the optimised algorithm. I converted this to assembly or used the assembly command.
30. The immortal rewrote the algorithm or predicate based on spec. I recognised the interpreter and turned it into a compiler by mapping its parts to a compiler, representing the bugs and filling in the rest. I could also notify the user of bugs. This method was controversial, as it transformed code. It would be easier to leave the interpreter with free choice points and run it in a compiler.
31. The immortal found their revolutionary idea by considering the merits of a bug in which findall didn’t work with nested predicates. I converted the findall clause with nested predicates to a line of findall statements that collected and processed data. I found the minimum data that findall could take at a time and changed it to a loop. I partially evaluated the given data. I eliminated choice points by pushing findall inwards.
32. The immortal discovered the academy model was easy. I handled free choice points with compiler code containing predicates written in assembly language. I found a “free” choice point outside findall. I inserted compiler code to handle execution from the choice point to each possible end point of the algorithm. I considered the merits of a computational philosophy academy, which required much depth of thought into several straightforward yet long algorithms.

33. The immortal ran difficult examples overnight or used code that would work after quickly identifying generated combinations. I found combinations of previous code in Lucian CI/CD, which was in a decision tree or neuronet. I also found combinations of type-compatible lines. I avoided errors by keeping different types of data structures in the same format and clearly labelled.
34. The immortal corrected incorrect test data. I avoided mistakes when writing the Lucian CI/CD test by calculating 1+1=2. The algorithm recognised 1 and 1 in the data and + in the tested algorithm. This stage was deduction and was before CI/CD. It verified test data against the algorithm output, assuming it was correct, so it needed human verification.
35. The immortal listed the input, of which there were multiple versions. I gave the algorithm the correct input for a particular output. This process sometimes relied on reverse calculation, reverse computation and reverse if-then. I inductively found an algorithm that found the input. I could find the algorithm from input and output, of which I already had the input.
36. The immortal flattened the structure to make finding predicates easier. Files in Lucian CI/CD could include others. I counted the files, I counted the links, and I flattened and reused structures.
37. The immortal made multiple files in Lucian CI/CD. I used numerous files in Lucian CI/CD. Multiple files were commonplace in algorithms. Single files were used for web apps. I could convert single files to multiple files using predicate name categorisation, utilitirisation and multi-levelling.
38. The immortal thought of new features based on code. I designated new main predicates within each file and a main predicate for each set of queries. This predicate was the main predicate for a query to a predicate. The main predicate could automatically be detected with or without queries.
39. The immortal separated and rated the usefulness of sets of predicates. The main predicates weren’t necessarily connected with other predicates. The predicates called predicates, but these sets could be unconnected with others. I detected each set and its top predicates. I deleted duplicate, unused or obsolete sets.
40. The immortal said that Lucian CI/CD was useful by itself, and CAW could be modified with types or replaced with tried data. I claimed that Combination Algorithm Writer (CAW) is more complex than Lucian CI/CD. CAW tried new commands in any order, whereas Lucian CI/CD tried instances of commands from a given order. Therefore, CAW was more complex than Lucian CI/CD.
41. The immortal said that program finder referred to pre-written algorithms that fitted certain constraints. CAW could reorder arguments. It could produce any configuration of commands and arguments. Types could tighten these arguments. “Program Finder”, an algorithm that could achieve specific kinds of ends, could isolate and insert delimiters such as commas in Lucian CI/CD.
42. The immortal used CAW to find unpredictable code. CAW could reorder commands. It could take a list of commands and produce them in any order. This order affected the instantiation or progress of variable values. CAW could find the optimal, optimised order.
43. The immortal could take apart commands’ tokens (variables in formulas). Lucian CI/CD could find 1+1=2 from 1+0=1 and 0+1=1. It put together 1 and 1 from these second and third equations and found when they summed to 2. This feature was helpful in debugging or, more quickly, finding a hidden configuration in the code. Another algorithm could find whether an algorithm systematically (always) missed a desired set of values and made a change that corrected it.
44. The immortal claimed that CAW was an essential tool in developing and refactoring neuronets, for unpredictable code that Lucian CI/CD couldn’t find. Lucian CI/CD could find string_concat(“a”, “b”, “ab”) from string_concat(“a”, “”, “a”) and string_concat(“”, “b”, “b”). This idea was similar to 43. Lucian CI/CD could find the right combination given the desired value and possible constraints. I replaced CAW with a database, which I possibly found with CAW.
45. The immortal modified CAW code with program finder with list-based conditionals. Lucian CI/CD could find append([1],[2],[1,2]) from append([1],[],[1]) and append([],[2],[2]). It could find any set of arguments of f for a particular value. CAW was better at finding an unknown, reordered number of arguments. Lucian CI/CD could quickly find a known, in-order number of arguments.
46. The immortal explained that automating main_file.txt generation implied that shorter algorithms may need measuring to be preferred. If a main_file.txt refers to no files (with predicates), it must contain []. The file, which must have a main_file.txt may have predicates but no main predicates (used for querying), in which case it must contain []. Without a main file defined correctly in this way, there would be an error as the main_file.txt file is needed to find dependencies in each repository. The main_file.txt file may be automatically generated based on a scan, assuming an effect of this was wanted to include or exclude specific files based on whether they were needed.
47. The immortal inserted a feature that connected disconnects in data flow or tried cutting them off. I planned to bug-test multiple Lucian CI/CD clauses. This was a feature of Lucian CI/CD. Later, it could reorder them, refactor them, or add base cases.
48. The immortal could have local dependency files if needed. I used the Package Manager’s registry file of dependencies of repositories in Lucian CI/CD. This file contained dependencies that could be found anywhere on the site. It could be used for dependencies within Lucian CI/CD repositories. The file contained dependencies in one place, which eliminated errors and duplicate data.

49. The immortal replaced variables in the Lucian CI/CD unit test with other variables. I entered more variables from Lucian CI/CD’s unit tester. I found data from the predicate that satisfied Lucian CI/CD tests. I found the inputs that had a particular set of outputs. If I needed a missing output, I found it with CAW.
50. The immortal removed all the outputs in an input-only predicate. I removed some variables from Lucian CI/CD’s unit tester. I found the variables that matched the unit test and removed the others. I listed all the variable values from the predicate for the inputs. I kept variables with a desired value for a model or set of assigned values.
51. The immortal considered compiling Lucian CI/CD’s algorithms. I made Lucian CI/CD as simple as possible. I tested for and removed unnecessary predicates, variables, lines of code, and parts of formulas. I allowed customising the time limit to run a predicate, after which possible infinite loops timed out. Simplifying and compiling the algorithm made it faster.
52. The immortal could test a^b or a+b, taking out items. I allowed the maximum number of items in Lucian CI/CD to be changed to find combinations. I could set an upper maximum of items to find combinations to save time when running Lucian CI/CD. I found the items a and b in the predicate and the combinations nothing and a and b and a, b. If the number of items to find combinations was one, only nothing or a or b would be chosen.
53. The immortal found the decision tree of the set of variables. I tested combinations of lines in Lucian CI/CD. I started again, consigning equality comparisons in if-then to program finder and inequality comparisons in if-then to CAW. Results of if-then with equality could be affirmed, i.e. given in a Prolog rule or set with assignments in the predicate body. Results of if-then with inequality were found from a set of data.
54. The immortal found the correct combination of base cases. I merged CI (testing) and CD (combination finding), although they were easier to test separately. I could test the algorithm with unit tests. I found combinations of predicates. As usual, I could find combinations of lines and unit-test them.
55. The immortal used sets to store common dependencies. I temporarily represented dependencies as relation lists. I found the dependencies from the repositories. I collected dependencies and referred to them a minimal number of times. I changed the code to refer to dependencies once.
56. The immortal used dependencies separate from the List Prolog Package Manager registry to complete Lucian CI/CD tests. I reused dependencies in Lucian CI/CD tests, which I noted in the readme file. These dependencies were used to build the algorithms for testing. I stored these dependencies as a term. I labelled this term in the readme file.
57. The immortal included all the code in one file. I created original Lucian CI/CD test dependencies, including terminals and circular references, which the List Prolog Package Manager (LPPM) resolved. I deleted circular references from the source files. In addition, I deleted them from the LPPM registry. I coalesced intermediate dependency sets.
58. The immortal removed the circular references. I resolved circular “:-include” references in Prolog. I found the system of dependencies within the algorithm. This method may span several repositories. I checked for cycles and produced an error on them.
58. The immortal routinely ran tests to warn about mistaken references in files. I resolved duplicate “:-include” references in Prolog. I listed each dependency in the set of repositories linked to the algorithm. I became suspicious of incorrectly behaving code and duplicate solutions, so I deleted duplicate “:-include” references.
59. The immortal checked all parts of the dependencies. I temporarily used new dependencies in Lucian CI/CD, tested them within Lucian CI/CD, and updated them in the LPPM registry file when the algorithm required. I used Lucian CI/CD as a container to test changes before integrating them.
60. The immortal sometimes changed predicate cycles into non-cycles for simplicity, for example, using findall instead of recursion. I tested the predicates in whichever order they were in the files. I constructed the necessary predicates, saving the finished set in their original files. I deleted empty files and references to these files.
61. The immortal merged files with similar functions or those used together and split files with the reverse properties. I used “:-include” statements as needed. I created a new file with novel predicates that optimised or added a new feature to the algorithm. I added a “:-include” statement to include this file. I merged or split similar files if needed.
62. The immortal reviewed and approved or rejected changes to files and retested them. I tested multiple files in Lucian CI/CD. These files were referred to by “:-include” statements and dependencies. There should be one system. I processed the list of files, reviewed them, and uploaded them.
63. The immortal analysed the files and converted the new files back to Prolog files. I merged the files with delimiters. I concatenated the files in a long List Prolog term, separated by delimiter comments. All predicates and Prolog commands could be manipulated and tested. Lucian CI/CD supported predicates and predicate calls using different logical structures.
64. The immortal found the best, pretty-printed combination of old and new code (with line spaces between predicates). I separated comments (using only those in the latest version). To prevent duplicated tests and comments, I only used the new version, not the old version. This step required adding and editing tests and comments in the latest version. I wrote tests that helped me choose from mixtures of the old and new versions.

65. The immortal wrote an algorithm that accepted plug-ins to find, replace and make conclusions. I tested combinations within predicate dependencies. I selected or found the proper predicate. This predicate was simple, met requirements and worked with other predicates (produced data with the correct form). I converted “Jan.” to “January” in the spreadsheet formula finder.
66. The immortal checked that the code’s data was correct. I used the algorithm to check the code. I checked the pattern-matching code, found the links, and produced the result in the appropriate format. I found data for a month or the number of days from one month to another. The algorithm found text and formulas with numbers, variables, and pointers to another cell.
67. The immortal stayed on the right track and examined finance logically. I used the algorithm for changing code. If asked about January, the algorithm searched in the tables. Instead of ignoring it or producing an error if there was an “f” (favourable) or “u” (unfavourable), I wrote a Prolog algorithm to add to my spreadsheet to find it (based on its number sign). I could analyse the data and answer the question.
68. The immortal more easily fetched tests. I automatically completed software using advanced programming skills, such as subterm with address. This predicate helped fetch and substitute changes to data easily, speeding up development time. I stored a database of the number of days per month to use in the spreadsheet algorithm. If there was an unknown value in the answer table body, I deleted it manually, left it there or wrote an algorithm to process it.
69. The immortal adjusted the algorithm to fix test results. I more easily used tests. I used my compiled interpreter to customise and quickly run tests. I made marks on my notes as a reminder to implement those features, where these notes were more straightforward and led to better features. I included necessary details, such as converting non-standard minus symbols, and prepared for extra spaces in formatting.
70. The immortal perfected the data. I simplified Lucian’s CI/CD display. I turned off discontiguous and singleton warnings. I imagined requesting the line number of errors. I wrote a predicate to repeat until it finds the same answer.
71. The immortal stated that the formulas found data structures. I checked that dependencies and “:-include” statements matched. I wrote down both lists and checked they had the same items. I didn’t remove duplicates during this process. The formula finder found unknown values or produced a warning.
72. The immortal used backtracking to match one of several row item addition results. I tested the non-mentioned files in Lucian CI/CD. I found each unincluded file, tested it in case it was needed, and reincluded it. I also found invisible files to test. I used the same formula in a row except the total. I found the first combination of values in the row with the correct sum or subtraction.
73. The immortal completed the report with unlinked files. Some invisible files were connected with “:-include” statements but were not mentioned as main files with main predicates to test. I automatically warned about these files and found whether they were useful. I effectively expanded to the most extensively used range when a first column had no value in a row. If this range was too small, more data could be added to train the model, which would snap to the span formulas.
74. The immortal made the job manageable and well-paid. I eliminated duplicate loaded files in Lucian CI/CD. I claimed that jagged columns (where a column referred to a number of a previous column’s previous rows) were found algorithmically. Instead of searching within a row or column, I searched within the last row or column. I eliminated duplicates in accounting.
75. The immortal centred the text for readability. I tested the files’ predicates from the central repository. I operated the business from a central location or server. I decided to search for data in rows with specific labels. These labels or similar ones were commonly used and recognisable.
76. The immortal carefully preserved table formatting by not deleting white space at the start of lines. I fixed an error in the tests, so the other repository’s predicates were tested from them. This error may be in the dependencies, the file path or a changed file. I deleted empty rows at the start if they didn’t contribute to the table formatting. Tables may either have newlines or tabs separating columns.
77. The immortal automatically detected likely data sources when given different versions of an answer using a formula finder. I changed the main_file.txt to refer to the necessary files. I omitted the main_file.txt and automatically tested the main predicates. If a number was unexplained in an accounting model answer, I highlighted it (and unfinished answers) and manually added a Prolog formula to find this given new date. For example, I displayed a “*” on “3” in the capital investment formula because it wasn’t printed anywhere else in the question but was the number of years used in the formula. The number of years corresponded to the rows with a specific label in the table.
78. The immortal rendered creative accounting report formats based on old ones, such as financial housekeeping. Repositories were constantly tested separately and did not rely on “:-include” statements. Instead, I rendered the files before running them using the LPPM dependencies. This helped them be in one place, sped up bug correction, and made installation easier. I replaced the values in the accounting model working (and gave the answer).
79. The immortal connected questions and program finder to act like a chatbot. I tested multiple repositories, bulk-tested them, and saved time with the program finder to help make corrections. I recognised spreadsheet question types and helped people with them. They examined and added to the open-source software, assisting with the accounting of education and advanced sciences.
80. The immortal stated that the spreadsheet formula finder was similar to the program finder with types because it found repeating types. I changed multiple repositories. I found the best configuration or combination of lines of the last two repository versions, including CAW and program finder changes, finishing projects in less time. I made row and column-spanning spreadsheet formulas from row and column numbers and found answers from new data. I recognised these rows from their label or position, found from multiple other answers.
"]