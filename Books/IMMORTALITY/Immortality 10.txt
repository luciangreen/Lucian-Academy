["Green, L 2022, <i>Immortality 10</i>, Lucian Academy Press, Melbourne.","Green, L 2022",1,"Immortality 10

1.  I couldn't add tail recursion optimisation if the recursive call were inside, for example, findall, where the cut command would have unwanted effects.  In tail recursion optimisation, I inserted brackets around the cut command and the recursive command, if needed.  I found each command that exited on status -2 (successfully exited) in the state machine.  I burrowed back until finding a recursive call, however many brackets it was inside.  I changed for example, recursive_call(A..B) to (!, recursive_call(A..B)).
2.  I benefited from all parts of life.  I did this by stopping the effects of social isolation.  As part of this, I saw people.  I felt like myself.  I took part in social events.
3.  I chose the most intelligent thoughts.  I had high distinctions for what appeared. First, I registered that the person had appeared.  I acknowledged them.  I gave the following high distinction in my specialisation to them.
4.  I found that breasoning currency accounted for activity and receiving.  I wrote questions and answers (a mea culpa) for my performance about aphoria (thinking of ideas).  I wrote that an aphor was a use, an algorithm topic and three steps. First, I invented ideas about ideas. Then, I expanded the steps and found rhizomatic connections.
5.  I worked out logical frames of objects.  I wrote questions and answers about breasonism (working out computational ideas), pointing at ontology or nothingness at the end.  I found the logical structure of thought and life. Study and life were in terms of algorithms.  I wrote enough and wrote systems that ported the most relevant ideas to a point.
6.  I checked that immortality would help.  Later, I helped the main role helper.  First, I visited the office.  My work gave me the role. Then, I checked the attributes of the position.
7.  I helped the female role helper.  She was friends with the leading role helper.  I wondered if she was a time traveller, but she was just friends with the former role helper.  I determined that time travellers might look like inhabitants.  I found out that she had gone home.
8.  I enjoyed visiting the office and talking with the staff.  As part of this, I helped the dark-haired role helper.  First, my employer gave me the role. Then, she asked about my career. After that, I worked in the role.

9.  I avoided death using a Master's degree and meditation.  Separately, I practised academic meditation.  First, I paid for puja. Then, using this, I indicated the utterances.  Also, using this, I indicated I had breasoned out breasonings.
10.  I wrote more and more specific ideas.  I started by writing 50 hand-written As for the encyclopedia article.  I first wrote the As.  I hand-wrote them in traditional style. After that, I wrote in a distinctive academic style.
11.  I tracked articles' relevance through time.  I began by writing 50 hand-written As for an essay.  I first wrote articles for the local newspaper.  I wrote an amount from a perspective. Then, I wrote from a standpoint during it.
12.  I met people.  I made friends with Eliza, the robot Head of State.  I avoided transgressions.  I also met the next Head of State, but time travelled to Eliza's time.  Eliza was an older woman, and the next Head of State was a middle-aged man.
13.  If a giant visited the simulation, they would appear our size.  Before the doctorate, I checked my previous degree's pedagogy notes about writing details.  I wrote in synthesised sentences.  I wrote in terms of the area of study's terminology.  I wrote enough detail.
14.  I could increase any sentence as much as necessary.  I generated 5 million breasonings for a doctoral assignment.  I could reduce this by removing the cited sentences.  Also, I could expand the breasonings' sentences and reduce the number of breasonings.  I breasoned out 5 million, not 4 million, to reach the copywriting standard.
15.  I interviewed people, researched industry publications and conducted statistical experiments in my doctorate.  At the doctoral level, I wrote 50 word-breasonings as details.  I first wrote the reason. Then, I wrote 50 words to detail it. Finally, I wrote details when I wrote original sentences.
16.  I benefited from having a mentor during my doctoral studies.  I also wrote on philosophy, computer science and education in my degree.  As part of this, I generated philosophies with business aims. In addition, I made induction more accessible.  Logical induction helped complete and checked philosophies.
17.  I recognised the need for performance and met it.  Earlier, I asked the lecturer to help with earning a high distinction.  Before this, I wrote an argument.  I drafted my assignment.  Then, I spoke with the lecturer about my draft.
18.  I wrote 5 million breasonings for each assignment, details and algorithms.  I wrote 250 algorithms per assignment.  Each predicate was an algorithm.  I scheduled writing parts of my philosophy using algorithms.  When I breasoned-out work, it contributed to the project.
19.  I designed an image font and other coloured icons as part of Philosophy Works in Prolog.  I added a Prolog test case which tested cut in the findall body in State Saving Interpreter.  It wouldn't easily work in List Prolog.  Cut limited the number of solutions of findall to one.  When the interpreter encountered a cut in the findall body, it finished finding solutions.
20.  I could change reserved words and syntax in List Prolog to be shorter and faster (the algorithms were all on the website in expanded form).  I changed v in List Prolog to sys_v (system variable).  Changing this variable signifier allowed me to use the string \"v\" in extended English mode for other purposes.  Changes like this enabled necessary words to be reserved by List Prolog.  I could change it to another name because the Prolog to List Prolog converter hid the variable's name.
21.  I gave the gift of life to my followers.  I changed n in List Prolog to sys_n (system name).  Since I added grammars to List Prolog, I needed \"n\" or similar to differentiate between strings to parse and predicates to call.  I changed \"n\" to a different string because \"n\" was commonly used by algorithms already.  For example, \"n\" in Vetusia conflicted with the interpreter in \"en2\" but not \"en\" mode (in which 'n' with single quotes would have conflicted with it).
22.  I back-propagated variable values in List Prolog.  I also changed \"=\" to behave like equals4.  I entered A=B, B=1.  The interpreter returned A=1, B=1.  Backpropagation of values also worked with lists and within \"=\".  For example, [A,A,B]=[1,C,C] returned A=1, B=1, C=1.
23.  I noticed a duck seemed almost human.  I used the Text to Breasonings to help animals become human-like.  I mind-read them in assignments.  They explored details for projects.  The ducks kept away from the dogs and had neat feathers.
23.  I supported inversion in the interpreter.  I entered reverse(A,[],[D,C,B]) in the interpreter.  The interpreter returned A=[B,C,D].  The interpreter sometimes merged variables with no value in other commands.  To prevent this, I used strings instead of empty variables.
24.  I experimented with n-queens as a free variable puzzle.  I swapped the variable names A, B, etc. for _1, _2, etc.  I kept variable names intact through calls and predicate heads (the interpreter displayed the same thing in the trace).  At the end, I swapped _1, _2, etc. back to A, B, etc.  I thought \"t\" looked like a king, \"8\" looked like a queen, \"#\" was a rook, \"+\" was a bishop, \"4\" looked like a knight and \"i\" looked like a pawn

25. I monadalised from a hierarchy to a list. I started with [1,[2,[3]]].  I converted it to the list [1,2,3]. There might be two items starting at the same level, for example, [1,[2,3]]. In this case, the algorithm introduced state numbers (if it was an if-then clause), e.g. [[1-2],[1-3]].
26. Functional optimisation called the same predicate with different arguments. I demonadalised from a list to a hierarchy. I used this technique to develop code from a state machine. First, I found the functional optimisation of the state machine. Then, I found the number in the string optimisation of the state machine.
27. I generated all possible inputs to the website to test it. I did this by testing many characters. Then, I tested all characters from a set. Finally, I tested two users at the same time. After that, I tried to break in and make certain combinations of inputs by the users cause a crash, which I solved.
28. I wrote data limitations in algorithm inputs to guide generated input. For example, I specified to enter a number from 1-10. Or, I wrote if a response was 1, then to go to a particular branch of the algorithm. I could also store my responses in variables. I could back-propagate variable values, given A=B, B=1, and check them.
29. I suggested apps save progress as they go, with the ability to return to a previous progress point. I wrote a simple way to have multiple buttons in the Prolog web app. I replaced buttons with text fields with multiple-choice answers. I replaced multi-choice questions with \"what\" or content questions. I converted between multi-choice questions (for example, is A B or C?) and \"what\" questions (for example, what is A?) and provided hints.

30.  I asked for a paraphrased multi-choice answer (when writing a quiz).  There were test scripts where rules guided answering multi-choice questions.  I wrote the rule that an answer needed a particular phrase in it.  The test script followed these rules.  For example, I changed the answer to lowercase, removed punctuation and found the base words together in order of the required phrase.
31.  There were practice data generators with multi-choice questions.  I wrote the possible answers. Next, I wrote a required phrase in each answer.  Then, I wrote the question flow from particular answers to help correct mistakes. Later, I consolidated with hints until the student answered correctly.
32.  I could swap from text file to web view to view a specific page.  I developed the app in Prolog.  I ran it with SSI, running the non-deterministic app on different web pages ending with a read field.  While editing part of the code as a web page, I could run the app to a point to view it in the browser.  A text file contained the instructions so far to reach that point.
33.  I asked for the client's name. Then, I generated instructions for filling in the fields.  To do this, I wrote the field name. Next, I wrote the pattern that the input needed to follow. Finally, I wrote an example of the input.
34.  I could sort by a column and update values based on data chains.  I optimised the app if the app requested the same patterns with different instructions. For example, I noted that the app asked for a word or a number.  I called this code or instructed it to do this twice, with different instructions.  I could generate various reports online, which I analysed.
35.  I could create, edit and delete parts of the database.  I did this to generate the no-code app from a text file.  I could view the data as strings or abbreviations.  I could create IDs for customers.  I could return errors if a record didn't exist.
36.  I formatted the web page from a database selection and checked boxes or numbers.  Earlier, I generated the app-generating text file using an algorithm.  This algorithm asked for specific information.  It gave a certain number of hints to similar questions.  For example, it was a document library or question-answer database.
37.  I could customise the database's background or the group email format.  Earlier, I could customise the app's number of levels, items per level, and cycles.  For example, I could specify an information retrieval system with various levels.  I could also store any number of items per level. Finally, I could also process the items and the pages using a recursive algorithm.
38.  I tracked the data about the entities and merged the databases. Then, I could convert by asking for several answers to findall and edit it.  I did this by inputting the data.  Alternatively, I edited specific rows.  In the end, I tried automating the spreadsheet.
39.  I used a database formula finder to write queries with the intersection, not, etc.  I could edit the text file with an algorithm and expand or collapse parts of the app flowchart.  I edited the access level of the column.  I gave the users certain levels of access.  I went into a movement of the app and expanded it.
40.  I could edit the text file with a graphical algorithm.  I generated the flowchart from the text file.  I edited the flowchart.  I visualised the web pages on one page, given the model data. Finally, I error-checked the app, with pages of the app devoted to this.
41.  I wrote an algorithm in Prolog, converted it to C, edited it, and then converted it back to Prolog.  As part of this, I wrote a converter from C to Prolog.  It conserved immutability (non-changing variable values).  It changed local and global variables.  It was a deterministic version of Prolog, which could run a compiler for non-determinism.
42.  I converted Prolog expressions to C expressions.  I changed \"is\" to \"=\".  For example, I converted A is B+1 to A = B+1.  A verification algorithm produced an error on A=A+1 because A's value should not change.  Also, +(A, B, C) had another function in C, which the program converted to C=A+B.
43.  I moved [A] in the Prolog head to the body.  I first wrote a([A]).  I converted this to a(B):-equals4(\"B\",\"[A]\").  I used a separate predicate for setting a string to a variable's value, for example, equals_string(C, \"string\").  I could also set an atom to a variable's value, using equals_atom(D, \"atom\").
44.  I could store the number type, string or atom with equals4 and unify variables with numbers later using a variable table.  I wrote [A] in the body with equals4.  I converted \"[A]\" to a tree in an array.  The algorithm stored this tree as B=list(C), C=var(A).  This tree representation couldn't reduce to B=list(A) because C has to be grounded in a terminal.
45.  I benefitted from the simplicity of Prolog and the speed of C.  I wrote the Prolog to C converter. First, I used SSI to process choice points in Prolog. Then, I ran SSI (which didn't process choice points using choice points in itself). Finally, I wrote a version of Prolog in C that only needed a list and command support to convert SSI.
46.  I inserted variables to convert if-then statements from Prolog to C.  I rewrote the if-then statement (a(1)->B;C) in Prolog as a(a1);if(a1==1){B}else{C} in C.  Also, I rewrote ((a(1),b(1))->B;C) in Prolog as a(a1);b(b1);if(a1 == 1 && b1 == 1){B}else{C} in C.  Also, I rewrote ((a(1)->true;b(1))->B;C) in Prolog as a(a1);b(b1);if(a1 == 1 || b1 == 1){B}else{C} in C.  I also rewrote the if-then statement (not(a(1))->B;C) in Prolog as a(a1);if(!a1==1){B}else{C} in C.

47.  Once the algorithm converted equals4 to C, it could use it to get and put values.  I wrote equals4([A],...) in Prolog as -> equals4(\"[A]\",...).  I transformed [A] to \"[A]\".  I transformed it into an atom with the string to list predicate.  As an example, I entered string_to_list(\"[[\\\"a\\\"]]\",A), giving A = [[\"a\"]].
48.  I could compile algorithms to use numbers instead of strings.  On a separate note, equals4 requires variables in a variable table.  I passed the variable table to equals4 and took the outputted variable table from it.  Expressions containing variables (for example, [v,_]) in List Prolog were not confused with strings, which the converter wrapped in \\\"...\\\".  I could directly set strings and atoms to variables with equals4(\"[v,a]\",\"\\\"string\\\"\") and equals4(\"[v,a]\",\"'atom'\") or equals4(\"[v,a]\",\"atom\"), respectively.
49.  List Prolog types contained recursive types and lists.  I converted from ((a(1),b(1,1))->B;C) in Prolog as a(a1);b(b1,b2);if(a1 == 1 && (b1 == 1 && b2 == 1)){B}else{C} in C.  Or, I converted from ((a(1),(b(1)->true;c(1)))->B;C) in Prolog as a(a1);b(b1);c(c1);if(a1 == 1 && (b1 == 1 || c1 == 1)){B}else{C} in C.  I added types to C to enable the algorithm to convert C into Javascript.
50.  I converted anded statements and clauses in Prolog to C.  I converted Prolog anded statements to nested if-then statements in C.    For example, a, b, c in Prolog was converted to if a then (if b then return 1, else return 0) else return 0.  There were no choice points, so this method accounted for failed predicates.  Also, clauses were joined together in a single function.   The converter renamed clauses, and a failed previous clause would lead to running the following clause.
51.  I converted C to Prolog to optimise or edit if-then clauses.  When converting from C to Prolog, I kept or changed back a(A1), if A1, then to A->B; C.  Note: this is the reverse direction from the previous examples.  I could keep or change back to A->B; C.  I could also convert back from (b1 == 1 && b2 == 1) to b(1,1) or b1(1),b2(1) in Prolog.
52.  The Result variable name needs to be different for each function.  A predicate call in Prolog may resemble a(A1, Result), which returns Result=0 or 1 based on whether it has successfully exited, which the calling predicate can test if-then.  If the interpreter successfully leaves a predicate, it must return Result=1.  The programmer should set Result=1 at the end of the predicate.  If a clause is successful, it returns Result=1, or if the predicate is unsuccessful, it returns Result=0.
53.  I converted some if-then clauses in C to if-then clauses in Prolog.  I checked if the logical structure was already there, so the converter didn't need to insert it.  For example, the algorithm only converted an if-then clause to one in Prolog if it had a filled-in else clause.  Otherwise, it left it as anded Prolog statements.  For example, if(A){B}else{Result=0} is converted to A,B and if(A){B}else{C} is converted to A->B;C.
54.  The C function doesn't return the result value.  Instead, the function sets Result to the logical result of the function.  In addition, it uses the variable table input and output variables, i.e. *vars_in and *vars_out.  These are local variables, treated as immutable, for conversion to Prolog.  I processed changes, additions, or deletions to the variable table in \"put value\" in equals4.
55.  I converted if-then clauses in C to different logical structures in Prolog.  I described how if A then B else fail function versus if A then B else C converts from C to Prolog differently.  As illustrated, the if A, then B else fail function converts to A, B in Prolog.  Also, if A, then B else C function converts to A->B; C in Prolog.   The programmer may replace A, B or C with A1->B1; C1, etc.
56.  I constructed the Prolog predicate to be in the form a(In1, In2, Out1, Out2).  These variables behaved like C *vars when converted to C.  I could take in1 as an input, and add to, change or delete part of it.  I could set the result to another variable or out1.  I could get the head or tail of a variable and copy or change an item.
57.  The Prolog to C converter used type and mode statements.  I converted A=1 in Prolog to C.  The conversion was the same, A=1 in C.  I also discriminated between 1==1 and A (undefined)=1 (an assignment).  Finally, I traced each variable's type (defined or undefined) with type statements.
58. I interchanged get_item_n(Array,Item_number,Item) and item=array[item_number].  I converted A=\"string\" in Prolog to C.  In C, it was char a[] = \"string\";.  Before this, I initialised the variable char a[100];.  I couldn't overwrite the string and could process the string one character at a time, which I could convert from C to Prolog.
59.  I tested that C variables behaved immutably.  Immutability meant that a variable's value couldn't be reassigned but could be read and operated on before assigning another value to another variable.  Before converting to C, I checked that the variables weren't assigned conflicting variables and that their modes didn't conflict.  When converting to C, once a programmer had created a variable, the programmer only compared it, so the verification algorithm didn't need to check it to be immutable.  I verified that C variables were immutable so that the algorithm could convert them to Prolog variables. 

60.  I inspected and made allowance for near-misses.  The output from the whole C algorithm was printed or outputted.  I started by creating unit tests for the C code.  First, I wrote the input. Then, I tested for the correct output.
61.  I tested the C algorithm in Prolog form to test the converter's correctness.  I started by converting the C algorithm to Prolog. Then, I kept function names for assignments or comparisons. After this, I tested the C algorithm for 100% correctness. Finally, I tested the Prolog algorithm for 100% correctness.
62.  I could more easily read and simplify List Prolog.  I created the LP-like-C to LP (where LP is List Prolog) converter.  \"List Prolog like C\" was List Prolog, with extra predicates to convert to C more easily.  I removed these predicates with the converter.  These included different predicates for assignment and comparison.
63.  I wrote in Prolog, then converted to C later, which I did with other algorithms that needed better performance.  I wrote the LP to LP-like-C converter.  This converter added predicates and allowed me to test algorithms in a C-like way, with trace in Prolog. For example, I could run \"frames\" or instances of running the ssi1 predicate for bug-checking.  I could solve problems before converting into C.
64.  I found it easier to change List Prolog like C to List Prolog by converting in terms of a state machine.  Before this, I ran LP-like-C to test code with additional predicates.  As part of this, I added equals4.  I also added arithmetic predicates. Finally, I added the variable table and result variables to the predicate head.
65.  List Prolog in this sense (not like C) meant contracted code in List Prolog.  Separately, I converted List Prolog-like-C to a state machine.  Then I removed its C'ness. Finally, I converted it to List Prolog.  I also used the state machine for converting from List Prolog to List Prolog-like-C.
66.  Sometimes, \"a(A1, A2), if A1 and A2...\" in LP-like-C wouldn't contract to a(A1, A2)->B; C in LP, so I left it the same because it might be too long (there might be too many statements in the antecedent or it might be unclear which ones they were).  I couldn't move all the statements in the predicate until then to the antecedent, so I only included the results.  If I reconverted this if-then clause to LP-like-C, it would remain in its original form.  Only if the original if-then clause, when converting from LP to LP-like-C, converted the result variable in the antecedent, then the shorter form of if-then (a(A1, A2)->B; C) could be used when converting to LP.  I needed to associate the result and other variables with the predicate call with the predicate and argument instances naming convention.
67.  The update variables predicate, etc., were needed in C and LP-like-C because the interpreter stored variable values in variable tables.  This storing was where the interpreter transferred values to the first arguments, and the algorithm listed variables in the antecedent if compared. The interpreter also passed the variable tables to all predicate calls. So I devised a new version of Prolog without lists in the predicate head.  There was no need to update variables at the end of the predicate because C took care of this or didn't. So I could run SSI-like-C.pl in SSI.
68.  I answered whether the interpreter needed to check arguments and update variables with C variables.  They weren't because predicate/function calls would return variable values, including lists as trees as arrays, which C would handle.  On the other hand, they were because equals4 produced more variables without them being individual arguments.  I copied the format with check arguments, etc., of List Prolog's member predicate, adjusting for different clauses of the member predicate.  I prepared to remove all arguments apart from variable tables and the result from function headers, requiring check arguments with a string of arguments, and results and other variables in if-then antecedents to be put, got and compared using predicates.
69.  I added interpreter commands to SSI.  As part of this, I added string codes.  I also added input and output predicates. Furthermore, I added a temporary run command.  In addition, I converted [A] in Prolog to \"[A]\" in Prolog-like-C code to edit terms more easily.
70.  I removed choice points from SSI.  I found the member call.  I replaced it with recursion.  Removing choice points from SSI allowed me to convert it to C more efficiently.  I also replaced multiple clauses with one clause.
71.  I removed choice points from SSI (for example, I converted findall to a predicate).  I replaced findall with recursion. Third, I optimised (eliminated unnecessary) findall statements. Fourth, I tried bringing back C variables instead of Prolog variable tables but used Prolog variable tables. Finally, I ran SSI to run algorithms.
72.  I tested Vetusia in User Input mode, in which the player controlled applying objects rather than the algorithm autorunning. Each object is applied to each object recursively whenever the algorithm picks an object up.  I ran Vetusia in UI mode to pinpoint the slowness of the interpreter (is it in a findall predicate or due to the stack size, which could be alleviated with tail recursion optimisation?)  I converted Vetusia to List Prolog, including using writeln.  As Vetusia UI didn't use apply_all_to_all (which caused a slow down), no slowdown in Vetusia UI would indicate that apply_all_to_all caused slowness because of no local stack.  If Vetusia was also slow, the stack is too bulky and needs tail recursion optimisation.
73.  I optimised the code in the compilation.  Earlier, I sped up the slow interpreter (with optimisers or local and global stacks).  I also eliminated records of intermediate variables and other unused values.  I could refer to repeating values using globals.  I counted the references to a variable, including from within itself and deleted variables to output.
74.  I wrote the interpreter's issue list.  I addressed and solved the issues. Then, I added ISO (International Organisation for Standardisation) Prolog commands.  I also added retry to trace. Finally, I explored the commands in terms of C.
75.  I created an API with web commands or a form of SSI Web Service written entirely in C.  I wrote the web issue list. Then, I found C commands to use to access and send information over the Internet.  First, I drafted the commands in LPI and SSI in Prolog.  Then I matched the output of these commands in Lucian Prolog (a compiler).
76.  With multithreading, I could save time and with immortality, I could achieve more.  I wrote a multithreading issue list.  I wrote 50 Bs and 50 Bs to Bs to immortality to prevent death during one's life.  After writing 50 As for immortality, I wrote these different books simultaneously.  I could keep on going forever.
77.  I found a simple solution to help me achieve my goals.  I wrote an append predicate that worked with multiple modes (append was run in SSI, not mode predicates for append).  I started again.  I didn't need the 50 Bs, etc., because dying to the first universe was unpreventable, immortality opened other doors in the universe, and keeping one's prime body was good.  The first action was to study business (after education to master business) to protect oneself.
78.  I distributed lucianpl.pl in non-like-c Prolog form, converted it twice on installation and ran it. First, I completed SSI (lucianpl). Then, I converted it to List Prolog-(which was) like-C.  Then I converted it to C. Finally, I ran the compiler after compiling it in C.
79.  I converted Prolog lists to C arrays.  First, I converted SSI to like-C Prolog, and C.  SSI didn't have choice points (even though it supported choice points it ran). So I could convert it to a longer form of Prolog like C that I could test.  Then, I converted it to C, with certain predicates swapped for functions to work in C, such as put value and list processing in equals4.
80.  I could research business decisions with 50 Bs (helped with a philosophy algorithm), it would be easier given my task and the solution (immortality) was in itself.  I could run choicepoint-less Prolog algorithms with the two converters, but it was better to run them in SSI (lucianpl). First, I could convert the choicepoint-less Prolog algorithm into like-C Prolog.  Then, I could convert it to C. Finally, however, I could test SSI by running it in itself.
"]