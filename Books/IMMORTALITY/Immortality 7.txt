["Green, L 2022, <i>Immortality 7</i>, Lucian Academy Press, Melbourne.","Green, L 2022",1,"Immortality 7

1.  I wrote an interpreter to parse the variable [v1, name].  I built a term argument by argument using append.  I wrote an alternative variable notation, [v1,name].  Variables had a name in the algorithm.  In listings and traces, the interpreter replaced variables with _1, _2, etc.
2.  I inverted reverse with the query reverse(B,[],[3,2,1]).  and program reverse([],A,A) :- !. reverse([A|D],B,C) :- reverse(D,[A|B],C),!. with the result B = [1, 2, 3].  As an arithmetic comparison, I rounded both values and tested whether they were equal.  I wrote a new predicate that deleted extra zeros after numbers and tested whether they were equal.  I back-moved from results to operations that formed them to find constraints.  For example, x^2+y=5 and x+y=3, so x=2 and y=1.
3.  I could use find whether points were on certain graphs. For example, I evaluated A is 2+3, returning A=5.  I could determine 5 is 2+B, returning B=3.  In the case of 5 is C+B, I needed -1 is C-B to find C=2 and B=3.  In the case of 5 is C+B+D, I needed -1 is (C-B)-D and 0=D (3 different equations for three unknown variables) to find C=2 and B=3.  
4.  I played the tower stacking game.  I added the global variable before the others.  I changed the global variable into a passed variable when I wanted.  I deleted the variable and re-added it after inserting a value in the middle.  I could remove the variable added just after adding it, like a stack, for example, a memory stack.
5.  I queued the items to be processed by the server.  I added the global variable after the others.  I stored the item in a queue, processing it when it reached the front of the queue.  Instead, I added an item to the global variable, determining the order.  I could store the queue in a file so the server could access it.
6.  In most cases, the interpreter displayed the atom in single quotes.  I determined whether the item was an atom.  An atom was a string shown without double quotes or a number.  If the string contained only letters, the interpreter displayed it without single quotes.  If the string was an equal or minus sign, the interpreter showed it in brackets.
7.  I could interchange letters for letters in a word. Then, I converted the string or atom to a list of string codes.  I could parse this list of codes with a grammar.  I could then also convert the character codes to characters using findall.  Or, I could directly convert the atom to a list of characters.
8.  I could replace certain character codes.  I converted the atom into codes, not a list of characters.  I could also convert the atom to characters to parse with a grammar.  I wrote the predicate to convert the atom to characters.  I wrote the C code to do this.
9.  After concatenating atoms, I could append the atom to other items.  At first, I concatenated the atoms rather than the strings.  The interpreter wrapped atoms containing double quotes in single quotes.  The interpreter wrapped strings containing double quotes in double-quotes.  Using program finder, I used atom concat to concatenate atoms where I had determined this was necessary.
10.  I noted that in A is 1.1+0.9, A = 2.0 (a float).  I determined whether the item was an atom or a number. Then, I could decide if the number was an integer or a float.  An integer was, e.g. 1, 2 or 3, and a float was, e.g. 1.1 or 1.0.  The number became a float when the interpreter added decimal places, i.e. integer+float=float.
11.  I found the length of the atom.  I could find the first character of the atom with atom_chars(abc,A),length(B,1),append(B,_,A),atom_chars(C,B), resulting in C=a.  I could find the last character with atom_chars(abc,A),length(B,1),append(_,B,A),atom_chars(C,B),!, resulting in C=c.  Even though I could find the first item of a list with length(B,1), append(B,_,[a,b,c]), I couldn't find the first item of an atom with atom_length(B,1),... because it returns an instantiation error.  I could write a predicate that did this.
12.  I used the same predicate for atom_chars as string_chars, except the wrapping quote was different.  I found the sublist using A=[a,b,c,d,e],append(C,B,A),append([b,c],D,B).  Of these results, C is the list before the sublist [b,c].  In addition, D is the list after the sublist [b,c].  I could find subatoms and substrings by first converting them with atom_chars(abcde,A), producing A = [a, b, c, d, e] or string_chars(\"abcde\",A), which produced A = [a, b, c, d, e].
13.  I used bagof, similar to findall, but returned non-labelled variables.  For example, bagof(A,(member(A,[1,2,3]),C=1),B) returned C = 1, B = [1, 2, 3].  Unlike setof, bagof doesn't sort results (to be [1,3]) in the following: bagof(A,(member(A,[1,1,3]),C=1),B), returning C = 1, B = [1, 1, 3].  I could also return two lists using the member command and a list of item numbers and get the item number.  I returned two lists and C (as above), different from recursive findall, which stores variables between passes.
14. I caught errors in the program with catch(1 is A,X,writeln(\"Error.\")) producing X=error(instantiation_error, context(system:(is)/2, _)).  If I ran throw(error(instantiation_error, context(system:(is)/2, _))), the interpreter would produce an error message to the user.  I could edit the program's code after the interpreter found the error.  If a predicate wasn't inverting because of an error in the interpreter, I wrote an inverting predicate.  I reported the errors with the file names and line numbers.
15.  I could find the character from the code.  I found the character's code.  For example, \"A\"'s code is 65.  The character code was how the interpreter stored the character.  I reported this value.  
16.  I added predicates to run a different form of Prolog.  I translated a predicate using another predicate.  I could also convert programming languages utilising this technique.  I temporarily renamed a predicate for debugging purposes.  I also changed a predicate name or moved predicates together.
17.  I found multiple clauses of a predicate or multiple clauses with a body.  I found whether a clause in memory had a given Head and Tail.  Certain predicates were interpreter-side, meaning they weren't visible.  I added and edited clauses.  I could find private clauses.
18.  I didn't overwrite a stream (I checked that the streams had different variables).  I closed a stream.  The stream could be a file.  I wrote files to contain terms without predicate names or full stops.  I could write files to include Prolog code.

19. I determined that the item was not a variable or an atom but a compound. Lists are compounds. Lists containing variables are compounds. I differentiated lists from lists containing the pipe \"|\" with the following algorithm: foldr(append,[[1|2]],[], A), which returns false because the list contains \"|\". I stated that foldr(append,[[1|[2]]],[],A) returned true even though it contained a \"|\" because the list simplified to [1,2].
20. I replaced variables with underscored variables and returned the correspondences with the original variables. I copied the term. For example, A1=[a,B],A2=[A,b],copy_term(A1,A2) returned A2=[a,b].  My interpreter took [A,B]=[C,D] and returned A = C and B = D.  The interpreter took A=B,B=C,C=D,C=1 and returned A = B, B = C, C = D, D = 1 (pushing ground terms down).  Also, it took A=B,A=C,A=D and returned A = B, B = C, C = D (defining variables in terms of a more recent variable).
21. I checked instances were together. I found all the predicates with a particular name and arity. I could discover predicate names from arities. Also, I could find arities from a predicate name. In addition, I could return all predicates and arities.
22. I adjusted the stack size for the algorithm. I did this by returning the Prolog flags in memory. First, I found the flag's values. Then, also, I could see the values' flags. Finally, I found whether the flag had a particular value.
23. I found the current input stream, i.e. its code. For example, the current input stream started as the keyboard and computer on which the user loaded Prolog. First, I could change the stream. Then, I could load from this stream. Then, I could change the stream back.
24. I found the current output stream, checking the algorithm didn't reuse it. For example, writing to each file required a new stream. I did this by opening the stream. Next, I wrote to the file. Then, I closed the stream.
25. I found that A is float(1) resulted in A = 1.0 and that A is float(1.0) resulted in A = 1.0, which I checked were floating point numbers or integers. I evaluated the functors. I found the sign (-1,-1.0,1 or 1.0).  Or, I found that float_integer_part(-2.5) resulted in A = -2.0 (a float, different from the ISO standard).  I found that A is float_fractional_part(-2.5) resulted in A = -0.5.
26. I found an algorithm that skipped over recursion (I renamed it). Before this, I found all the interpretations of the spec. Then, I found the first n solutions to the spec. After that, I contained the lists of new combinants (sic)(possible features). I found combinations of features that skipped over the need for others (an optimisation).
27. I experimented with changing the flag value. I wrote the Prolog flags. I flagged the freedom of variables in recursive findall. Also, I found the inverse of free recursive findall. The inverse had the same number of statements as variables.
28. I read the decimal point in the number. I determined whether the number was a floating point number. For example, 1.0 is a floating point number, but 1 is not. It didn't matter if the user instantiated the variable; the variable collected the rule. Later, the free variable met the spec.
29. I accepted input from forms and printed the HTML table using recursive findall. I automatically flushed output at the start of the following line. I made my terminal or web algorithm that allowed writing at an (X, Y) location. I also displayed graphics. I could display input fields.
30. I created the functor A=b(_,_) with functor(A,b,2).  Later, I could set its arguments with args with A=b(_,_),arg(1,A,c) resulting in A = b(c, _). I computed b(c,d)=..E returned E = [b, c, d].  I could also produce functors with arity 0, e.g. b. I produced b with F=..[b].
31. I synchronised the music and graphics (the graphics followed the music). I got a byte from a stream. For example, I got MIDI music. I also got the vector or bitmap graphics. I modified them and saved them.
32. I got a single character from input, also online. Before this, I programmed the game. It was a role-playing game. In it was a recursive findall puzzle. In it, data flowed in a circle until the result was correct.
33. I taught string to list at the Academy, compensating for spaces. I got the next character from the file, returning -1 if it was the end of the file. I read the entire file using a grammar. I also converted the string from the file into a term. I processed this term using a Prolog algorithm.
34. I could automatically run the algorithm with crontab -e. I halted the interpreter. I halted the interpreter when the algorithm had finished. I returned with exit status 0, signalling that the interpreter had completed the algorithm successfully. Exit status 1 signified a minor error.

35. I wrote the algorithm writing helper.  I traced the data flow in the hooks defined in the implementation of Prolog. Then, I named the current file. Fourth, I reported the undefined variables. Finally, I said probable errors, such as numbers of items in terms not corresponding, failures from calling undefined predicates and lack of a base case.
36. If there were no recurring variables, I converted recursion to findall. I generated the algorithm with a program finder with types.  If a number was an integer, I appended it in recursion.  The part of the algorithm that found the integer condition was CAW for numbers.  I named the predicate \"collect integers\".
37. The last term in A=B, A=1, B=2 becomes 1=2, failing.  I determined the input and output of variables.  I defined all variables as a value when I defined them as a variable given that value.  The variable, e.g. _1 with the value _2 equalling the variable _3 with the value _4 caused _3 to equal _2.  Also, given A=B, B=1, the result was A=1, demonstrating that the interpreter propagated ground values before returning from the predicate.
38. I stored and optionally used SLG tabling results on a server.  I controlled logic with not, once and repeat.  I ran useful algorithms multiple times.  I ran them with a set of data once.  The interpreter used SLG tabling to speed up repeated computations.
39. I solved spelling errors, mistyped names and supported back-compatibility. I wrote a self-correcting algorithm that solved non-existent variables.  Also, it solved uninstantiated variables.  I changed the variable name from A to _1 for security.  The interpreter changed these back before being outputted.
40. Logical terms are true or false, which \"not\" inverts.  I wrote that the variable was not a number.  So, it could be an atom, string, list or list with a pipe at the first level.  I determined that the item was not a list with a pipe at the first level but a list.  I counted the pipes at each level, e.g. foldr(append,[[a],[b,[c|d]]],[],A) where A = [a, b, [c|d]].
41. I determined whether the number was an integer or a float.  If it was an integer, I left it as it was.  I truncated it to the integer closer to zero if it was a float.  If it was an atom, I converted it to a number.  If this returned false (meaning I couldn't convert it to a number), I repeated asking for input.
42. I inserted cuts where necessary. I converted a number to characters using number_string(11,A),string_codes(A,C),findall(B,(member(B1,C),char_code(B,B1)),D).  The result was D = ['1', '1'].  I found likely bugs, such as breaks in chains of variables.  Also, I found likely bugs in base cases.
43. I verified the number was from a certain system.  I converted a number to string codes.  I accomplished this with a number_string(11,A),string_codes(A,C).  This resulted in C = [49, 49].  I could also convert codes to a number using  string_codes(A,[49,49]),number_string(B,A), with the result B = 11.
44. I always caught and solved errors and aborted to a level.  I ran statements (i.e. a) once.  The code \"once(a)\" had the same effect as b:-c. c:-a,!.  I could use once more than once in a predicate.  Other statements in the predicate could have more than one set of results, i.e., non-deterministic.
45. I organised files' contents by group, including control over a compiled application's executable and data portions.  I opened a stream from the virtual file.  The file was an item in the data file for the user.  Also, I organised the file by folder and name.  I used a variable for operations on a current file.
46. I wrote the font to the HTML page. I invented new font characters to be operators.  I also gave them a particular order of priority.  For example, I wrote a predicate that sorted items or combined a Prolog command with arithmetic.  There was an unusual xf or yf (postfix type) operator.
47. I changed the functors ',' or sin.  I found the bit-wise complement of -1 with A is \\(-1), resulting in A = 0.  The arithmetic functors such as the power of, sin and sqrt produced floats from integers or floats.  The bit-wise functors such as \"bit-wise right shift\" and \"bit-wise and\" produced integers from integers or floats. I couldn't change the functors ',' or sin.
48. The algorithm was verified and assessed using tests.  At first, I peeked at the next byte in the stream. Then, I invented a custom programming language to stream data.  These were videos.  They explained my philosophy and how to teach and assess programming assignments.
49. When the student saw me, I could give my thoughts.  I found the next character in the stream.  I checked the students were making progress on their assignments with version control.  The tests were simple enough to work when the program started working.  The high-quality thoughts were details (other algorithms), 250 per assignment for three subjects.
50. I earned a high distinction.  I peeked at the code on the stream.  I scheduled writing the algorithms for my degree.  I planned to write the algorithms for my institution.  PhD and vocational assignments also had this requirement.

51. I created a video explaining how to say what you are saying to be thought of to program.  I put a byte on the stream.  I remembered the idea that I aimed to program.  I listened to the concept of to program.  I worked out the idea to program.
52. I explained the idea as a reference (what the command means).  At first, I put a character, code or new line on the stream.  I explained the command.  I explained the algorithm.  I explained the differences and connections between particular commands and algorithms.
53. Thought, and sensory data, followed by movement, required the most considerable amount of data.  I did this by reading from the binary stream. First, I made a binary stream of bytes.  It could be video, music or robotic thought.  I also checked whether the robot's body movements required a stream.
54. I avoided variable names describing variable values in the interpreter for security.  Leading to this, I wrote characters as input and output.  With this, I wrote the text interface for the algorithm.  I determined what the user wanted and needed.  I wrote the algorithm.  I wrote for the future and past and to have compatibility between algorithms.
55. I converted the text from the speaker.  I did this by reading from text streams.  From this, I breasoned out text. Next, I wrote algorithms specified by the stream. Finally, I wrote an essay about a stream.
56. I found the non-singletons.  I read terms from user input.  Given read_term(A,[variables(B)]) and input a:-b(C),d(E), the interpreter returned A =  (a:-b(_A), d(_B)), B = [_A, _B].  Given read_term(A,[variable_names(B)]) and a:-b(C),d(E), the interpreter returned A =  (a:-b(_A), d(_B)), B = ['C'=_A, 'E'=_B].  Given read_term(A,[singletons(B)]) and input a:-b(C),d(E),f(C), the interpreter returned A =  (a:-b(_A), d(_B), f(_A)), B = ['E'=_B].
57. I used a key with enough digits to be secure.  Towards this, I repeated from \"repeat\" if there was a failure. Then, I cut to the first output. Then, I could generate a key.  If the key already existed, I could create another one.
58. I added new clauses.  Separately, I retracted a predicate with a particular name and arity.  I could still detect the deleted clauses with the current predicate command.  I could replace clauses, all of which I had deleted. Finally, I could list and error check if I had deleted them.
59. I opened files with phrase_from_file_s(string(String_dict2), \"file.txt\"), string_codes(String_dict1,String_dict2), atom_to_term(String_dict1,String_dict,_) and wrote to them with term_to_atom(String_dict,String_dict1),	(open_s(\"file.txt\",write,Stream1),	write(Stream1,String_dict1),	close(Stream1)).  I set the input stream to a particular stream.  I could open a particular file.  I could open, access and close a file.  I could also write to files.
60. Recursive \"set of\" collected values from recurring variables while sorting a list of items, and could skip appending to recurring variables if the clause failed.  Similarly to \"find all\", I found a sorted set of list and other items collected during find all.  For example, after entering setof(A,(member(A,[1,2,3]),C=1),B), the interpreter returned C = 1, B = [1, 2, 3]. Set of sorting unlike bag of, after entering setof(A,(member(A,[1,1,3]),C=1),B), the interpreter returned C = 1, B = [1, 3].  I wrote a custom predicate with the interpreter, recursive set of, which deleted duplicates by checking that items were not a member and appending items to a recurring variable.
61. I checked whether the text was ethical.  I set the output to a specific stream.  I checked the spelling and outputted the correct spelling.  Similarly, I checked the grammar.  Also, I checked the mathematics.
62. I edited the stream with markers.  I set the stream position.  I found the stream position using position.  I set the position to this.  I went to a particular position in playback.
63. I found the stream property.  For example, I found the file name.  Or, I found the stream position. Then, I found the mode (read, write, or append).  There were many options, including the binary or text type of the stream.
64. I found the end of the file.  For example, I determined whether the position was at the end of the stream.  Separately, another property was whether the program connected the stream with input.  An additional property was whether the algorithm joined the stream with output. Finally, I determined whether the stream had an alias and what it was.
65. At the end of the stream, I could pass an error, create an \"end of file\" code or reset to \"end of stream\" at a position.  I selected and controlled the stream.  When I started the stream, I could determine whether it was a text (the default) or a binary stream.  I could also decide whether or not I could reposition the stream.  In addition, I could determine that an atom A is the alias of the stream.
66. I also used atomic_list_concat(A,'.','a.b.c') to return A = [a, b, c]. I found the subatom of the atom.  For example, I entered sub_atom(abcdef,1,3,2,bcd).  In this, 1 was the length before, 3 was the subatom length, 2 was the length afterwards, and bcd is the subatom of abcdef given these parameters.  I could find anagrams (prefixes and suffixes of words).

67.  I detected a bug in which a>=x>=b, not a>x>=b.  I compared whether one term was less than, less than or equal to, equal to another, etc.  I tested whether there was a bug compared with the specification.  Alternatively, I tested whether there was a bug compared with the input.  I could insert predicate calls to determine whether indicated variable values were equal, etc.
68.  I created and decomposed a term.  In BASIC, I could make an array with a term in it. For example, I could convert a string to a number or store it in a different array. Then, I could call this term.  I could also decompose and build it.
69. I deleted the code if the inputs were always the same.  I optimised the code as I ran it.  If the input was the same, I used the same result.  Alternatively, I used the same result if the API parameters were the same.  If the random number was the same, I used the same result.
70.  I could avoid unification if a variable appeared in terms of another variable.  I did this by writing the Prolog unification algorithm.  First, I substituted variable values into both sides.  Second, I found undefined variable values by unifying the two sides. Finally, I compensated for the pipe (\"|\") symbol between the head items and the tail of the list.
71.  I could unify with occurs check.  I checked whether a variable appeared in terms of another variable.  If the two sides had different functions, the unification would fail.  If there were no unifications of variables with values, then the interpreter would return no variable values.  I could return atom=X, or if X=atom, then replace X with atom elsewhere, or if X=f(X) fails with a positive check.
72. I could manually create a List Prolog term, for example [[a],[b,c]].  I entered a(b,c)=..D., with the result D = [a, b, c].  Secondly, I entered [a,b,c]=..E. with the result E = ['[|]', a, [b, c]].  Thirdly, I entered F=..[',',a,[b,c]]. returning F =  (a, [b, c]).  I also entered F=..['.',a,[b,c]]., returning F = a.[b, c].
73.  I returned the type of the variable.  I returned whether a term was a variable.  In List Prolog, I returned that [v,x] was a variable.  In another interpreter, [v1,x] was a variable.  I could convert another form of List Prolog, X, into this form of List Prolog using a grammar.
74.  I wrote the term.  I could define various types of brackets.  For example, <a>.  Another example is {b}.  Also another example is /c\\.
75.  The algorithm format entry system wrote the algorithm using a program finder with types (in fact, descriptions) as I entered descriptions of the algorithm's parts.  I wrote the algorithm format entry system (I found the algorithm and its use).  I did this by breaking down the algorithm into functions (I broke equals4 into put and get values).  The algorithm entry system broke down the algorithm into parts.  It asked whether a part was in terms of a part or was separate.
76.  I pretty-printed the predicate generated with program finder with types.  I wrote equals4 with program finder with types by intelligently simplifying brackets where possible, etc.  In paragraph 75, the description might be sort addresses, interpreted as sort a list of lists (which addresses are), where the program finder recognises the sort predicate name and data (like types or a description).  The connections between, for example, the user would store addresses and a list of lists in an ontologies database.  The algorithm format entry system might ask whether the user wants to sort a list, then appended (dependently) or sorted, then pretty-printed (independently).
77.  I wrote string to list with program finder with types, identifying parts within parts and writing a grammar. First, this algorithm recognised the brackets.  To do this, I converted the brackets to a list. Second, I recognised commas in List Prolog strings. Finally, I converted commas to list item delimiters.
78.  I found that the person had decomposed the list but not transformed the list item.  I found bugs by comparing the specification with the code.  I drafted the code.  I wrote a simplification of the algorithm using the specification and program finder with types and combination algorithm writer.  I identified similar cognitive steps in the code and corrected errors.
79.  I identified that the user was trying to decompose a list but used the member command by accident.  I found a predicate that finds cognitive reasons for code; for example, decompose and build an item in a predicate.  The item started as [A, B].  It ended as [A+1,B+1] (calculated).  I wrote algorithms that identified decomposition, transformation and building lists.
80.  I could merge two or more predicates if possible.  I found a bug in which the code is in a separate predicate.  The user used two predicates, one called by another.  The called predicate was not recursive or reused.  I move the contents of the second predicate into the first predicate, changing the variable names if necessary.

"]