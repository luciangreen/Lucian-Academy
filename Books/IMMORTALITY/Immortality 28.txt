["Green, L 2024, <i>Immortality 28</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Immortality 28

1. The immortal wrote that Cute Prolog had arrays only, which could work like lists, and C-native modules for non-immutability, and converted recursive predicates to maplist, then C loops. I wrote Cute Prolog, which compiled to C and had immutable variables. Cute meant C-(imm)ute(able) (sic), where immutable variables prevented errors. It provided warnings on singletons. It had a range of features like Prolog and was fast like C. The trade-off speed was on account of not having clauses and having logic in separate commands.
2. The immortal stored strings as lists of numbers for speed. CN-ute (sic) Prolog contained numbers only. Strings were converted to lists of numbers on compilation and processed as numbers in grammars and predicates. The lists of numbers were converted back to strings before list building (where lists were broken into number and string arrays on compilation) and output. I only kept relevant lines in the arrays and deleted unused arrays.
3. The immortal preserved formatting in the programming language. I researched a universal programming language like List Prolog, which encoded subarguments as lists. Given \"int main()
{
    /*  */
    return 0;
}\", the C/List Prolog conversion is 
\"[
[[n,main],[[-1,int]],
[
    [[n,comment],[\"/*  */\\\"]],
    [[n,return],[0]]
]]
]\". This format differs from List Prolog and would be labelled as being converted from C, with relevant parts. Other languages would have different conversions.
4. The immortal converted the immutable variables. Cute Prolog had a module that converted between a range of tables and terms. For example, the term [[a,1],[a,2]] was converted to the number and string tables. The compiler processed terms, storing terms as arrays. Immutable variables were converted to non-immutable variables by inserting, deleting and replacing parts of terms.
5. The immortal stated that Cute Prolog (CP) had no multiple clauses, unlike Prolog. CP was not a logical programming language but had logical commands. It avoided choice points in clauses and outside logical commands, avoiding slowdown from choice points and if-then. CP had base cases built into functions and avoided opening frames unnecessarily. It avoided cuts by avoiding multiple clauses.
6. The immortal stated that multiple clauses gave input or accepted output. Assuming no cuts, Cute Prolog had multiple clauses, but these were converted to a single function. There were no non-deterministic results (multiple results from different predicates). Data that Prolog would store in clauses was stored in text files or as lists by Cute Prolog. The code:
\"a(A):-findall(B,b(B),A).
b(1).
b(2).\" became:
\"a(A):-findall(B,(b(B1),member(B,B1)),A).
b([1,2]).\" and could be further simplified and converted to C.
7. The immortal gave the example of multiple clauses giving input, where additional examples could also accept output. In the above, in the case that \"b([C, D]) :- c(C),d(D). c(1). c(2). d(3). d(4).\", the non-determinism of these results were converted to findall, then a nested loop and returned. I.e. \"?- findall([A,B],(member(A,[1,2]),member(B,[3,4])),C).
C = [[1, 3], [1, 4], [2, 3], [2, 4]].\". When asked, \"Why Cute?\" I replied, \"Cute Prolog gives the advantage of intuitiveness of Prolog and the performance of C\".
8. The immortal stated that the compiler broke complex antecedents into C antecedents. In the case that multiple clauses accepted output,  \"?- b(1,A). b(1,2). b(3,4).\", the multiple clauses were combined on compilation to \"b(A,B) :- (A=1->B=2;(A=3->B=4)).\". In the case of \"c(5,6)->...\", the compiler would break it into \"c(5,R),(R=6->...\" to avoid indicating choice points. Logical antecedents could contain \"and/(,)\" and \"or/(;)\". For example \"((A=1,B=2)->...\" and \"((A=1;B=2)->...\".
9. The immortal claimed that Cute Prolog went in one direction, so it didn't need choice points and was part of Prolog because it contained logic programming. In Cute Prolog, like lucianpl, nested findall was converted to loops. A new loop was started on member. Or, it could start on append with two outputs. Append with other modes could be converted to C.
10. The immortal converted Prolog to Cute Prolog and back, preferring it in projects because it was faster and could omit C libraries. The user could enter the code at the Cute Prolog prompt, which would return the result. It would give an error on a query or code that called non-deterministic clauses outside findall, etc. It provided an error on cut. It converted code and removed immutable \"dead-end\" code.
11. The immortal warned on further finite or possibly infinite (but cut-off) non-deterministic results. If-then is fast in Cute Prolog. If-then doesn't need to delete choice points to maintain performance. If the first or first n results are required, recursive code is necessary to do this manually. Cute Prolog could accept cut, and the code would converted to recursive code that does this manually.
12. The immortal used the array type with structures with a constant dimension and structure. Cute Prolog converted some terms to multi-dimensional arrays for simplicity. These terms had one type: numbers or strings. In them, lists of lists are translated to a multi-dimensional array using type statements. These arrays were compact and could be quickly processed.
13. The immortal combined and simplified cut, non-determinism, multiple clauses and choice points in Cute Prolog. Cute Prolog promoted fast development because it was based on Prolog. Prolog enabled processing lists of lists with nested findall. Intermediate C code could be examined concerning the original Cute Prolog code. Repeating code could be reused.
14. The immortal caught all failures and errors, for example, from illegal input, and wrote the logic programming language Cute Prolog. I customised the programming language with possible choice points, immutable variables and multiple clauses. Multiple clauses were a type of choice point and could be omitted. Immutable variables refer to disallowing assignment to assigned variables. Choice points were created by specific commands and were returned to on failure in a logic programming language until there were none left.
15. The immortal helped visually impaired users feel the layout. I wrote the graphical terminal in the web page. The graphical terminal had icons. Also, the graphical terminal had images and 3D graphics. The graphical terminal could run apps and supported multiple windows and the mouse.
16. The immortal wrote the neuronetwork on the encyclopedia article with ten sentences. I wrote a 12-sentence paragraph. The first sentence was a use. The second sentence was the main sentence. The other sentences expanded the main sentence.

17. The immortal used an algorithm to find parts of speech. For new meditators, I found parts of speech with fewer instances of detailed mind reading, faster mind reading and predominantly random selection. To check parts of speech in a sentence or any other task I needed mind reading for, I used the least amount of the most expensive, most effective mind reading technique, detailed mind reading. I also used the second priority technique, fast mind reading, which didn’t use a decision tree but directly selected from options. In addition, I used the third priority technique, the random selection of parts of speech, which was more effective with 50 meditators supporting and toning the results.
18. The immortal found similar text files and synthesised them. I programmed a catch timeout for the Breasoning Algorithm Writer (BAG) algorithm. BAG synthesised sentences from available word pairs (from AB, CB, CD to AD and all combinations) to reveal possible new meanings a text reader may interpret. The timeout limit on BAG stopped more complicated algorithm runs on texts but ensured faster results from more texts. The time taken to process a text was exponentially related to its length.
19. The immortal prioritised and ran the algorithms. I found the time of the BAG computations from the logs. I could record the start time of the day’s computation. From the end time and this, I could calculate the time taken to run the algorithm, and the time varied because the choice of synthesis varied, affecting the algorithm’s speed.
20. The immortal wrote down an interpretation of the conversation. I used BAG to give others As for As I received. I detected the A and noumenon for it I was given. I replied with an A in meditation. BAG helped interpret the topic, inspiring thought.
21. The immortal developed an algorithm to meet spiritual professional requirements for immortality using the classical computer. I used BAG to count all the breasonings, even failed ones. I measured the thoughts, such as preparing and reasoning behind choices. I counted the sentences, which were also known as breasonings. These breasonings, found rapidly, provided spiritual medicine and immortality.
22. The immortal could at least feel the data. I used BAG to count and stop when algorithms and arguments each reached n sentences. I measured the breasonings as I went. I stopped on n breasonings. This ending was announced with a buzzer and speech notification.
23. The immortal finished the algorithm after exactly n items. I counted all the breasonings generated by BAG (when the algorithm had finished, I added the extra ones in the cache). I ended the algorithm after n items. The overflow items were placed in the cache. I counted these and added them to the total recorded in the log.
24. The immortal helped the entities to have a better quality of life. I wrote day2.pl to run BAG until it reached its goal. It ran the algorithm that concurrently ran BAG in a shell container. I played the bell. The computer voice Agnes announced, “Freezing Ages Complete”.
25. The immortal wrote an ultra-fast breasoning algorithm that looked up the dimensions of objects with the maplist command. I wrote bag_args21.pl and its counterpart for algorithms to run BAG (using multithreading) concurrently. Another algorithm had prepared the texts in the folder, including the most recent ones, for BAG. It felt good to have written enough texts (16*50 high distinctions with sentence breasonings) for running BAG with n (= 3.2 million) items. Multithreading helped compensate for slow texts and allowed faster breasoning.
26. The immortal stated that people were quizzed and gave better results. I wrote the BAG algorithm. The algorithm variant read texts from another program rather than the disk, speeding it up and allowing portability. The BAG algorithm found split sentences and all possible connections and chose from these randomly. A spiritual glitch appeared to improve the results of this random selector.
27. The immortal discussed non-transgressional ideas spiritually. I needed one person each BAG person faced to be done, too. The person running the algorithm helped give a copy to people they met. These people could work out and run the algorithm in their own time. Eventually, society’s aim and a positive effect were achieved.
28. The immortal debated whether the “budding” was diverging or converging. I breasoned out 4*50 high distinctions for breasoning out facial expressions. These were expressive in acting and conveyed the thoughts of the character. People were joyful, amused, interested or listening intently. They remembered the faces and became a single person.
29. The immortal preferred the colour red. I breasoned out five red squares as seen-as versions for the BAG output. I found this by running the command N=1,M=u,texttobr(5,u,\"square\",M). There were five, one for each of four sets of 50 high distinctions and an extra one at the professor level. These squares could change colour randomly from day to day.
30. The immortal left files as they were, using algorithms to intersplice them. I moved the data files for luciancicd to another folder to reduce clutter. The files included history, modification dates and tests. I could change the history files to the same format as the original programming language files. In Lucian CI/CD, I could preserve the formatting of different languages and manipulate the commands to find the desired combinations.
31. The immortal monitored and auto-typed the repository, changing to a correct configuration on an error. I moved GitHub/private2 to GitHub-private2. GitHub was the name of the folder on which Lucian CI/CD operated and was constantly monitored for changes needed for new tests. I wrote an algorithm that found the types of each predicate and checked that these fitted together (without calculating all possible types based on other predicates). This type of verification circumvented the need for writing tests and highlighted possibly incorrect lines.
32. The immortal devised GitL, a graphical user interface that allowed viewing a repository’s history and making commits. I stated that GitHub-private2 referred to the files in GitHub. The files in GitHub-private2 contained the history, modification dates and tests of these files. The history included the history of the repository, the modification dates were the modification dates of the files to compare changes, and the tests were the tests scanned from the files. The files for each stage of history were together.

33. The immortal structured the work with research questions and hypotheses. I built the sales network. I focused on what I was selling. I focused on its features, unique selling points and frequently asked questions. I applied each set of the 4*50 breasonings to the product at the start, then 80 breasonings for each sale.
34. The immortal studied and collected As in social work, really computer science to interest people. I cold-called, built the latest technology and invested in sales points. I cold-called people who were likely to be interested in the product (I started working at the company in another role, for example, in prisons, with people with disabilities or in a school). I designed and constructed new computer science to write longer, more customisable (less exclusive) algorithms. I invested in people who were likely to flower.
35. The immortal was more impactful in person. I cold-called the person. I visited their office. I handed them a letter. I had dinner with them to explain my business proposal.
36. The immortal designed an algorithm writer with functional calls and relative, not absolute, functional building blocks, which hyper-optimised user-friendly code. I built an algorithm to write more extended algorithms. I kept it private. I wrote a simpler, safe version. The algorithm had features written bottom-up using ontologies of features, matching an expanded description.
37. The immortal travelled to help the person. I invested in the prospect. I found the person. I gave them high distinctions when they were given high distinctions in time. They did business with me because they felt it was necessary.
38. The immortal wrote in terms of their areas of study, which were safe and creative. I researched parts of the idea, from institution areas of study to industry knowledge and giving high distinctions to academics' children as Vedic astrology. I researched medicine, law, education, computer science and philosophy. I explored establishing a company, an educational institution and other social facilities. The standard high distinctions given to academics' children were on topics checked against political sliders, such as computer science, to be on our side, as necessary. 
39. The immortal developed 4*50 As as their industry, favouring education, information industries and business. I researched areas of study compatible with my areas of study. In medicine, I found natural, non-invasive and safe areas of study supporting computational spiritual medicine. The institution helped support work and technology. It provided jobs and supported the local economy, for example, a teacher of Lucian CI/CD.
40. The immortal kept accreditation, a technology hub and middle management for technology in their sights. I gathered industry knowledge for my goal. I examined successful and unsuccessful business models, analysing variable values explaining them. I collated case studies recording reasons for the success or failure of competitors and businesses in the area. I was sensitive to local customs, researching beliefs about immortality in lore.
41. The immortal promised in sales, delivered in marketing, and the top finished computer science for all. I wrote on Vedic astrology. I mind read people directly. I gave academics' children high distinctions for their interests. Vedic astrology meant the seen-as version of an academy, sometimes with manual assignments to help sales.
42. The immortal used the body and mind as frameworks to rotate weaknesses. I completed my humanities areas of study, from Love to Body and Mind Metaphors and Neuronetworks. Neuronetworks gave simplified, long algorithms capable of human understanding with a natural life expectancy of one month. They could reuse robot bodies, and illegal ones on clouds were deleted. In Love, I wrote on intrapersonal intelligence or subtle reactions to questions.
43. The immortal found the solution using itself. I organised aromatherapy and literature as seen-as versions for a computer science professor. The professor had sufficient high distinctions to work out the solution to the problem. I started again. I found the bottom-up solution. It was for the bottom-up Lucian CI/CD algorithm.
44. The immortal helped the hens complete their high distinctions and algorithms. I researched each part of local religions. I found compatible parts with liberal philosophy, immortality and computer science. I emphasised the deserved reward for enough effort (4*50 high distinctions). The meditators became essential members of the community and helped with important tasks.
45. The immortal kept their solution secret, adding details when the student had finished parts. I delivered computer science solutions. I found the way the programmer had attempted the problem. I found a range of approaches. I chose the one closest to that of the student.
46. The immortal wrote a non-neuronetwork to write a maplist algorithm. I stated that the neuronetwork was not me. I could develop one that responded to research questions, making hypotheses and writing algorithms. I wrote three professor-level predicate algorithms, usually with a maplist function, file processor and interface. It could easily integrate with other algorithms.
47. The immortal rated whether the thought was mind, tiring or noteworthy. I examined clouds of mind reading data. I mind-read myself. I stopped when the thoughts had been mapped, or I felt tired. I found thoughts from thoughts.
48. The immortal imported the C function into List Prolog. I was critical of the split on non-alpha and split on non-alpha, except for quotes being slow. I tried maplist. The split string algorithm was fast. I could write a C function in Prolog.

49. The immortal halved the algorithm length. I flipped the sides in Prolog constraints. In 2=A+B, I flipped the sides so that I could also find A+B=2. I flipped the sides so that A+B was on the right. I evaluated A and B, given their domains. The results came from finding every combination of the domain values that satisfied the rule.
50. The immortal found constraints for any formula with two variables. I wrote a single algorithm that found Prolog constraints with +, -, * and /. I read the formula. I substituted the operator into the formula to check. I found all the constraints that satisfied the formula.
51. The immortal calculated test data up to n for the neuronetwork. I found constraints with any number of variables with a neuronetwork. The neuronetwork quickly found constraints with more than two variables. It was trained on integer data. Maths worked with all combinations of smaller integers.
52. The immortal combined the code to find constraints for +, -, * and / with =, <, > and \\=. I wrote a single algorithm that found Prolog constraints with =, <, > and \\=. I read the formula. I substituted the operator into the formula to check. I found all the constraints that satisfied the formula.
53. The immortal found answers with n decimal places. I wrote a plug-in to specialise in a kind of formula with constraints. For example, I wrote y=1/x. I found all the floating point answers for a range of values. I found the answer using a slider algorithm.
54. The immortal experimented with non-neuronetworks (sic). I found data for the neuronetwork. I calculated answers for all formulas with particular formulas of values. I trained the neuronetwork. It quickly looked up the answer.
55. The immortal experimented with mathematical constraints. I asked, \"What about the Mathematics department?\" I allowed formulas and floating point values. I found trigonometric, polynomial and complex formulas. I found answers in terms of surds and fractions.
56. The immortal quickly found constraints with few variables. I only had two things I could spend money on. I could find solutions to multi-variable systems with a domain for each variable. I could solve constraint satisfaction problems with the member predicate in List Prolog. I put back member2 for use with Combination Algorithm Writer (CAW).
57. The immortal solved B+C=B*C. I simplified A=1, A+1=B+C to 2=B+C. I determined that all the terms on one side of the equation were ground and simplified. Then, the constraint satisfaction formula solver found B and C. If A was in terms of further variables, I solved it, perhaps limiting B and C.
58. The immortal stated that CAW algorithms for strings could have their constraints solved. I simplified A+1=B+C+1 to A=B+C. I subtracted one from both sides. Or I simplified A*1=B*C*1 to A=B*C. I did this by removing *1 from both sides.
59. The immortal said it was still an ordered constraint satisfaction problem. The data had a non-numerical domain. For example, it may be a, b or c. Also, it could be converted if the data was correct but the wrong type. I found A=a and B=b from append(A, B,[a,b]).
60. The immortal made up the simplification game. I simplified the algorithm with the list constraint solver. For example, I started with append([], B, C). I simplified this to B=C. If possible, I removed C.
61. The immortal minimised the code. I simplified the hard-coded levels, each with a different type, using the list constraint solver. Given append(A, B, C), append(D,[], A), I simplified them to append(D, B, C). I could streamline \"string concats\". Given string_concat(A, B, C) string_concat(D, \"\", A), I simplified them to string_concat(D, B, C).
62. The immortal could combine foldr append and foldr string_concat. I simplified the hard-coded items per level using the list constraint solver. I could simplify appends with more than three arguments. Given foldr(append,[A,B,C],[],D), foldr(append,[E,[],F],[],A), I rewrote them to foldr(append,[E,F,B,C],[],D). Given foldr(string_concat,[A, B, C], \"\", D), foldr(string_concat,[E, \"\", F], \"\", A), I rewrote them to foldr(string_concat,[E, F, B, C], \"\", D).
levels, items per level - hardcoding
63. The immortal could flatten and then concatenate items in a list. I combined foldr append and foldr string_concat. I wrote foldr(append,[A,[foldr(string_concat,[B,C])],D]). With A=[a], B=\"b\", C=\"c\", and D=[d], this equalled [a, bc,d]. I could apply foldr(string_concat) to this list.
64. The immortal found the timetable always had enough time for the \"text to breasonings\" algorithm. If the constraint result was greater than a particular value, then a conversion was coming. If A in A+B=3 was greater than 2, I converted the square to wiggly vines. I climbed up the vines. I was in heaven on Earth.

65. The immortal simplified each popular predicate call. I simplified get_n_item (which was different from get_item_n) because it got the index of an item from a list. For example, I usually wrote get_n_item([1,2,4], A, 4), returning A=3. I simplified it to [1,2,3]**[4, A]. So, B=[2,4],B**[2,A] returned A=1.
66. The immortal experimented with the infinite choice point [1..]. I simplified the numbers predicate. I usually wrote numbers(4,1,[],Ns), returning Ns=[1,2,3,4]. I simplified the call to [1..4]*Ns. So, B=3,[1..B]*Ns returned Ns=[1,2,3].
67. The immortal minimised the idea to a few lines. I added features with strict simplicity as a prerequisite. I simplified the code to strict simplicity, possibly changing its behaviour. It was a prerequisite for circuit design, state machines and faster code. I stored a straightforward version and one with connections.
68. The immortal kept redrafting and adding features. I saved the simple version of the code. I stayed with the positive seen-as version. I compared each part of the more extended algorithm with the simple algorithm, starting bottom-up. I found the human-like features that one naturally wanted.
69. The immortal took ways of thinking from texts, such as any result delivered to one's door. The neuronetwork was deep and like mind reading, and it improved ideas. It improved ideas by taking away thoughts until just before losing meaning. The model lost too much meaning, which was corrected later. For example, it stated that lists should be in the form 1,2,3 rather than [1,2,3], presenting challenges given lists of lists, such as [1,[2],3]:
1
 2
3.
70. The immortal saved the zeal of algorithm writing. I explored my video album. I treasured friends, memories and creations. I examined the hard copy of the documentation for my computer programs, explaining how they worked and walk-throughs. I made videos about each turn and decision in the algorithm's creation.
71. The immortal found property and phenomenology-based science. The human outlaid the wanted features of the robot. I examined the mind's eleven dimensions. The data was stored in eleven dimensions. The computer could organise work and use science, while the robot could conduct experiments, creating immortality.
72. The immortal joked that it was like writing an interpreter and that safety laws were a major priority. I specified the robot's programming requirements. I noticed one robot lasted a month. Another was a robot that seemed to lack confidence. I took the robot's mind with me on a space trip.
73. The immortal was determined not to break any laws. I listed the implications of the robot's programming requirements. I interviewed myself and the simulated future robot to find positive topics. Testing and correction were taken care of by algorithms. It was increasingly crucial with homemade spaceships, time travel and flying car algorithms.
74. The immortal wrote a paragraph to prepare for writing complex code. The robot mind software was available to any skill level. I combined human-like features with simple commands. I explored the commands as a programmer, asking the computer to do what I wanted. For example, I wrote Lucian CI/CD to focus on and fix individual predicates with human-like commands such as \"incorporate bug fixes found in the past\", \"explain the change/code,\" and \"give secure code (anyway)\".
75. The immortal analysed the cut command's behaviour before programming it. The robot software could be a child's friend, a teenager's friend or offer advanced simulated insights into circuit design or learning how a computer worked. The child learned advanced computer science, such as interpreters in primary school, which required mathematics such as calculus, linear algebra, discrete mathematics and logic. The robot didn't skip over any thoughts of the person and was like a meditative companion. The robot encouraged using full brain potential, with high distinctions mind mapped with the student.
76. The immortal categorised knowledge as essential to an extent or non-necessary (for a purpose). The robot programming language was laissez-faire in that it was imaginative. The human was laissez-faire, but the code was tight. There were exceptions if the science needed correction or the feature required differentiation. The physical single answer was to reach perfect correctness to a standard.
77. The immortal simulated the board, forming strategy and levels of analysis. I taught the robot my thoughts from the start. The robot either copied me, or I instructed it. There was a growing brain simulator, which learned at the same rate as a human. I expected it to be critically held, like the reference list and style copier.
78. The immortal used GL to check whether the person was still enrolled in short courses. I wrote a code generator with \"types of types\" (music) and \"types of types of types\" (write the rhythm, melody and harmony), applied to predicates with functional calls, where original code was reduced to intermediate predicates, and code was generated from hierarchies of sentences. An algorithm could take options that increase the features. The code writer and discusser had data on debugging, testing, and new GL Logic found random (mind-read) words to encourage programmers to use relevant ideas as stepping stones or identify that they haven't covered a prerequisite.
79. The immortal ran the algorithm on itself, for example, drawing Lucian Hand Bit Map's state machine with itself. I said the answer before the question was asked. I read the question before reading the possible answers. I did this before the question was asked. I predicted the question from the previous discussions, the reading and other sources.
80. The immortal covered the person's seen-as version (that of a person born on another date). I controlled mind reading. I decided to focus on myself. I enjoyed it, like a fresh spring shower and feeling like my thoughts were cared for. The beautiful buds bloomed as 4*50 As were found for each line from GL and breasoned out.
"]