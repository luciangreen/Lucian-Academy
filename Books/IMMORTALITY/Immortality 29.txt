["Green, L 2024, <i>Immortality 29</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Immortality 29

1. The immortal captured and changed a simple algorithm using natural language. I connected and wrote additions to simple algorithms to achieve the desired effect. I had the algorithm in my mind's eye. I knew what changes it needed to work. I focused on natural language, which specified each type of simple algorithm.
2. The immortal claimed the other algorithm was incomplete but inspiring. I changed the algorithm, starting bottom-up with the more extended algorithm. I wrote the bottom predicates first. Below them, I wrote the driver algorithm. I aimed for clarity about simplicity in the neuronetwork, not one that appeared to achieve complex results.
3. The immortal wanted features that were new or attractive to explore. I found the human-like features of the algorithm that I wanted. If I wanted the feature, it was human-like. The computer wanted to help. The computer wanted harmony to reduce stress and encourage human achievement.
4. The immortal wrote a concise Prolog compiler for a smaller system. I took the way of thinking from my text. I explored three-level syntheses of texts. These started with texts focusing on themselves. Then, I applied different books to each other.
5. The immortal described the human whims through the times. I delivered the information to the user's fingertips. The latest neuronetwork appeared to suggest ideas about, not finish ideas. I claimed that any idea could be simplified. Human-demanded features were intuitive yet challenging to program.
6. The immortal claimed the neuronetwork was deep. It wasn't easy to write all parts of the neuronetwork. They were written by hand. The bottom parts appeared to clear away parts, sometimes unnecessarily. This criticality could be interpreted as creativity, a record of the history of thought.
7. The immortal always used all the best ideas, like a checklist. I examined humanness, which I claimed was giving a special status to preferred parts and then building on them. These parts were meditated on and prepared over time. I wrote the best ways of thinking, such as focusing on a predicate by itself. I examined it in terms of data from the rest of the algorithm.
8. The immortal mind read any question, possibly limiting to computational terms. The neuronetwork used mind reading. This attribute could be turned on or off. Mind reading used the computer as an antenna to guess identified thoughts from the length of time an argument took to breason out (spiritually think of the x, y and z dimensions). I repeated GL (Grammar Logic) ideas, found using mind reading until they were recorded.
9. The immortal skipped over neuronetworks by writing an algorithm that modified algorithms for different data structures and recognised the need for more complicated processing derived from existing algorithms. The neuronetwork's mind reading improved ideas. Detailed music mind reading (using a decision tree) gave instruments a more resounding, three-dimensional sound. It and crystal reading could be applied to GL texts and algorithms. Detailed mind reading would traverse a decision tree of a dictionary or a possible set of commands.
10. The immortal used ontologies to join needed parts together using types. The complex processing was derived from existing algorithms. I identified the standard core processes. For example, I wrote a post-processing algorithm for \"find dependencies\" that grouped clauses from dependencies by grouping clauses and comparing versions. I assumed the latest version of different parties' attempts at parts of the repository (in which versions were compared) contained all features, and a maximum of these two versions could be merged.
11. The immortal gauged the neuronetwork on a simple slider. The neuronetwork improved ideas by removing thoughts until just before losing meaning. It did this to achieve creativity in the name of function. There was a top result in this category. The neuronetwork found this result.
12. The immortal was hungry for future technologies. The model lost meaning by being too simple. There was a slider inside the neuronetwork. It had the settings simple, give the bottom-up question's answer or categories for an answer, research the answer more complex and genius. Genius instantly created an extended algorithm, explaining it in documentation and future directions.
13. The immortal created a longer compiler with all commands and code C-compatible. I was the primary person to my non-neuronetwork in the present. I worked out all my algorithms from first principles, understood how more complex ones were built from simpler parts and was with-it in the present. I researched how predicate IDs were tracked in the interpreter. In addition, I kept the Prolog stack, assignment stack and heap separate.
14. The immortal comma-delimited lists as arguments in predicate calls. I stored the list [1,[2],3] in the algorithm:
1
 2
3.
Also, I stored the list [1,[2,4,[5]],3] in the algorithm:
1
 2 4
  5
3.
This method pretty-printed the term. I could edit terms and argument maps quickly using this format.
15. The immortal made a presentation about the program in the form of a play, poem or song, with an unusual object-based movie and box. I saved the zeal of algorithm writing. This zeal might be a musical instrument playing a particular melody or harmony, an icon or other work I completed. I carefully presented the documentation, caveats and easter eggs for the algorithm. I captured my vision for technology or art as the seen-as version of the algorithm.
16. The immortal publicly released the vlog. I watched my video album. I filmed an interview with myself describing decisions about the interface, method or running the algorithm. I got others involved and redrafted and tested the software. I also filmed myself pretending to visit places and wrote a textual record about it. 

17. The immortal went from strength to strength. The robot encouraged the human to use their whole brain potential. The robot noticed the human had almost finished reasoning. They helped them to finish it and any further reasonings this brought up. The robot helped humans finish breasonings, correct mistakes, and finish arguments.
18. The immortal examined theory, epistemology and the history of the thought. The robot encouraged mind mapping high distinctions with the student. I focused on intrareasonings (sic). Intrareasonings were inspired by eating fruit by dissecting parts into finer and finer parts. I examined etymology, science and history.
19. The immortal gave the repository version numbers. I categorised knowledge as essential. I used GitL, a version control system, to publicise specific commits. Each commit had a version number calculated from its API changes, new features and bug fixes. Connected repositories could be connected and were linked to download together.
20. The immortal defended the general algorithms, spiritually connecting them to the topic. I categorised knowledge as good and improved it. I joined between parts of texts and texts. The same inspiring ways of thinking were used. I integrated the file processor, file diff, web service and find dependencies.
21. The immortal generated multiple possible specs for a predicate and checked for unwanted extra results from predicates in Lucian CI/CD. I determined that the algorithm's purpose was useful. I returned to my algorithms, using my ideas and only publishing stable versions from GitL. I wrote on radical purposes, waiting until the version was complete before committing it and only committing code passed with Lucian CI/CD. Lucian CI/CD could read input from files, check for writeln \"output\" by converting to and from a command that checks strings and check writing to files (kept writeln and specific other commands).
22. The immortal wrote an algorithm to correct logical errors, which jumped to the simple version. The programming language was laissez-faire in that it was creative. The interpreter knew what I meant. It was open to errors, wrote code and corrected logical errors. The fourth version number type was the percentage of the bug fixed, from identifying the bug to isolating it, repairing it, testing it, simplifying it and testing it again.
23. The immortal identified the failure necessary to fix it. I allowed customising the time limit for Lucian CI/CD testing. This time limit was in the settings file. Some algorithms needed time to finish a computation. Others may have hung and need to be failed.
24. The immortal called the algorithm writing algorithm the waterfall model because it worked in stages, requiring enough input to link to the human's previous ideas (in ways the human has programmed) to build the software. The programmer was laissez-faire. The algorithm had its own life, seeming to write itself. The programmer sets its aim, its initial features and a way to achieve its aim with these features. I preferred user-friendly, necessary features.
25. The immortal alternatively typed in the code given an exciting prompt and the related music, which I had mind-read and prepared beforehand for the event. The algorithm writing algorithm required enough input to link to the human's previous ideas. I noted the date of the way of thinking. I found concordances containing it and selected the relevant one. I chose from options and linkages, checking I understood each one.
26. The immortal's \"I program\" social movement emphasises the human's importance in their work without pointing away. I linked to my ideas in ways that I had programmed. I looked at my idea and thought, \"I can use that idea in this way, and this is how to do it\". It was also mind-read for the time by me overnight, and I was handed the answer. I discarded the unknown neuronetworks and relied on the ones in my brain, increased with music, art, details and other algorithms.
27. The immortal predicted user needs intuitively and wrote a programming language to express this. I wrote tight code - the algorithm writing algorithm modularised code mimicking Prolog. Prolog compressed whole functions into maplist and findall, which could be edited and transverted (sic) to C, and languages that were elegant at the task through the empathy of a user interface or result. Transversion treated programming languages like a written language and contained language that more easily described programming.
28. The immortal tried programming the crystal to vibrate and alert the computer when a bug had been found, a way of thinking could be used, or an image was thought of. The mind reading programming language was native at mind reading, using words and objects that the mind recognised. The mind was lazy, preferring verbose (A=[B|C]) list decomposition (rather than [A|B] in a predicate call), and required developed spiritual objects to support thinking, such as detail circuits that helped with memory, weren't distracting and waited for the human to arrive at conclusions, during which a break at any time was available. A game could help the mind prefer [A|B] in a predicate call to A=[B|C] and append at first, and the pauses were realised to be necessary details for enough thinking in research. The sharp mind followed the phases of research for each thought, including inspiration, drafting, filing in code, testing and debugging, and again (twice) simplifying and writing to clarify the representation.
29. The immortal examined the specific quality of the crystal, for example, amethyst for meditation, turquoise to help with restlessness during meditation, stimulate awareness with purple fluorite, attain depth with kunzite, enter the void with azurite and melt into golden ecstasy with rhodochrosite. The computer admitted there were exceptions if the science needed correction. The computer corrected its science if the human was part of a team, if access wasn't good enough, if web access was required, or if live results were needed.
30. There were recognised standards to insert mistakes in the neuronetwork if it was relied on to educate or be changed and checked. The computer differentiated the feature. The feature was the closest to what I wanted. There was enough data for it to meet the requirements. It could be determined with needed options.
31. The immortal wrote and performed. The physicist wanted objects and conclusions, and the philosopher wanted ideas and reasons. It was easier to write philosophy. Knowledge of physics gave me the ability to time travel, mind read and become immortal with these skills. With the invention of computers, people could remain immortal in their home times.
32. The immortal generated jobs with computational philosophy. I simulated the company board. Each member focused on a particular book. The company board members had reached their positions through specific business departments. The books and courses generated profit and supported industries.

33. The immortal used mind reading CAW and pattern-matching program finder to write connective algorithms. I formed the company strategy. I used viral parts of my philosophy to increase the main products. Virality depended on high ranking, according to mind-reading people. I thought of connections between philosophies in the main product and the viral philosophies.
34. The immortal wrote an option to write an index for the HTML file. I wrote modules for the CAW dictionary, including diff folders, finding files and folders in a folder, Prolog converters preserving formatting, and operator expected error finders. I found the files and folders in two folders and found differences between them. I recorded all the characters in a unit (a command) and used these when manipulating the List Prolog code. I preserved the characters' formatting when rebuilding the code.
35. The immortal kept a(a(a)) or this and three such as a(b(c)) as types. Lucian CI/CD identified calls without output and kept them instead of checking whether they should be kept. I found the types of each predicate and command in the algorithm bottom-up. I eliminated incorrect modes and found the modes for each call from the predicates. I found the minimum number of tests to test the algorithm and refactored the code using Lucian CI/CD.
36. The immortal found the grand dependency of code over time. I worked out what the good features were from the types. I added the feature that completed code using types. I found end-points, simpler interfaces and more elegant programming features. The type checker ran in the background, notifying the user of bugs, completed code and errors as end-point features.
37. The immortal made advanced computing easier. The simpler interfaces were simple types, entering predicates to query at the prompt and Prolog detecting type errors from code. I wrote a method to treat lists enclosed in \"[]\", \"()\" and \"{}\" or subsets of these the same. I entered the predicates with \"|\" instead of full stops between predicates and queried them. On compilation, I detected whether the code would run, corrections, possible tests and the types.
38. The immortal simplified the algorithm to use fewer instructions. I wrote more elegant programming features. I used foldr, maplist, findall and subterm with address to process available levels until the end and substitute items without complicated list processing. For example, I replaced [a] in [[a],[[a]]] with {a}. Subterms with addresses could be recursively called, with replacements made at each scope level.
39. The immortal tidied up list building (as against decomposition), formulas and decomposition, using mind reading. I completed the code using types. The whole algorithm was considered. As I entered the code, the algorithm guessed and made recommendations to achieve, simplify and add features to the code. In addition, it suggested deleting extraneous code and quickly finished advanced features.
40. The immortal gave a \"zen\" view of the algorithm, suggesting the simplest form. The type checker notified the user of bugs. These included incorrect types, bracket problems, incorrect numbers used in \"numbers,\" and incorrect order of arguments. The correct function was predicted, and the helper algorithm suggested it. I wrote an algorithm to change algorithms systematically, such as changing a language's syntax, adding commands or uniformising tested code.
41. The immortal found the code bottom-up or top-down. The type checker completed the code. I reduced the data to that needing computation. I gave the spec as a hint. I predicted extra predicates needed.
42. The immortal found and ordered the most popular predicates before the others. I reused the simple types idea with numbered brackets to portray different data types. I described specification types as lists of string and list item variables. I could bug check, use functional calls and autocomplete. I compressed intermediate predicates into functional calls or called them as more straightforward, all-in-one calls.
43. The immortal eliminated compilation warnings. I entered predicates, which were saved for future use. I could delete or modify the predicates. I override Prolog's rule not to allow predicates to be asserted. The predicates could be written and run in a shell or checked not to conflict with other predicates.
44. The immortal wrote the find dependencies algorithm after the post-order depth-first traversal algorithm. Prolog detected type errors from code. I mind-read idea inspirations. These were noumena of parts of complex algorithms. I prepared for an algorithm by writing a similar, smaller algorithm.
45. The immortal limited append to work with one bracket type set. I wrote a method to treat lists enclosed in \"[]\", \"()\" and \"{}\" or subsets of these the same. First, I identified the bracket type. Then, I found its head, tail, and head elements or applied append. Append and other predicates preserved the bracket type.
46. The immortal warned the user if a predicate would be overwritten. I wrote the predicates in memory and dragged them into a new order. I listed the predicates and their numbers. I entered the from and to numbers. I could also shift sets of numbers to a new place. In addition, I identified the needed order from depth-first pre-order traversal.
47. The immortal found the reasoning skill and completed the task. I mind-read the philosophies for better results when preparing to write a movie. I used connectors such as \"because\", \"using the same method as\", \"creating an interface inspired by\" or \"redo like\". I asked questions to fill in parts of the answer's hierarchy, such as \"What movie elements does the algorithm need?\" \"Can the API-intensive algorithm bulk process the data?\" or \"What programming language can I make for the algorithm?\".
48. The immortal listed (non-data-and-constant-and-variable-specific) types for each predicate. On compilation, I detected whether the code would run. I found the types for the code. I worked out whether the program would work. I predicted the tests.

49. The immortal claimed two different constants couldn’t equal each other, and listed equivalent lists of strings. I determined the types of the code. I worked out that string a was concatenated to string b. In addition, I learned that concatenating a string to string b, resulting in string c, meant that the first string was string a. I also worked out if two strings could be the same.
50. The immortal notified the user about unnecessary nondeterministic results and edited them. I worked out whether the program would work. There was just enough information about a list of items and constants to determine whether an append operation would work. I listed the principal but not all the possible specs from the types. In addition, string concat was similar to append in that it could work out the output of get token-style parsing of strings containing string variables and constants.
51. The immortal tested commands were compatible with each other. I worked the tests out. I found the types. I simplified the nondeterministic list of types to the most useful ones per predicate (for example, ones that used each command in the interpreter). I found the algorithm’s types then wrote tests from them.
52. The immortal suggested corrections to incompatible tests. I checked the human-written tests against the types. I found the types for the algorithm. I verified that the tests were compatible with them. I listed the consistent tests and produced errors about the incompatible tests.
53. The immortal named types after their constituent types. I grouped the recurring types. I constructed a hierarchy of types containing disjunctives. I wrote intermediate types to define types with the same beginnings and ends but different middles. The records of types allowed easier identification of types and reuse across types.
54. The immortal kept the number of results to the successful results. I could operate on two different sets of items with append. I kept families of commands in types-to-be-tests and worked on them in parallel. The developed types that resulted in concise, meaningful results were saved. I kept examples of recursion and non-failures.
55. The immortal merged types of different algorithms, and merged algorithms. I merged similar lists of items in the types, and kept the different parts separate. I wrote the same types in one place. I changed them to include different types. I pointed the different types to the same algorithm.
56. The immortal could specify the length of string variables. I determined that string a was concatenated to string b. I wrote A= “a”. Then I wrote B= “b”. With the command string_concat(A, B, C), I worked out that the type of C was (const “a”: const “b”).
57. The immortal eliminated code concatenating empty strings. I learned that concatenating a string to string b resulted in string c, which meant that the first string was string a. For example, I wrote B=\"b\", string_concat(A,B,C). This C’s type is (string a: const “b”). This fact means that A’s type is string a.
58. The immortal could remove unnecessary code in the following case. I determined if two strings in the extended type system could be identical. For example, I wrote string(A), string(B). Then, I wrote A=B. I learned that these variables were the same, so they had the same type.
59. I filled out types bottom-up. I worked out if two strings in extended types were the same. For example, I wrote A= “a”, string(B). Then, I wrote A=B. I learned that these variables were the same, so they had the same type.
60. The immortal stated the extended type, const string””. I found unnecessary nondeterministic results in extended types. For example, I read A=””, A=””. This expression contained an empty string, which is either processed by a base case or may be unnecessary. In addition, there were two copies of A=””, so I deleted them.
61. The immortal gave the extended types false or const string []. I deleted the unnecessary nondeterministic extended type. The extended type may be false or []. This type was excessive, so I deleted it. Deleting this type led to keeping more essential types.
62. The immortal stated that a constant of a type would fit into a variable of that type. I worked out whether the program would work with an extended types statement. The program was a(A, B):-string(A), b(A, B). b(C, B):-string_concat(C,\"d\",B). I worked out b’s types were b((var string c), (var string c: const string “d”)):-string_concat((var string c), “d”,(var string c: const string “d”)). From this, I worked out a’s types were a((var string a), (var string a: const string “d”)):- string((var string a)), b((var string a),(var string a: const string “d”)). If string(A) were replaced with string(“a”), then A’s type would be (const string “a”), but it wouldn’t affect b’s type statement because other predicates might call b.
63. The immortal cut down the number of possible types from the algorithm. There was just enough information about a list of items and constants to determine whether an append operation would work. I listed the possible input types in the predicate. I found the possible results of the append predicate, using these types. For example, append([A],B,[string,string]) returned A=string, B=[string], and append([A],B,[string,string,number]) returned A=string, B=[string, number].
64. The immortal also tried each command with similar and different commands. I listed the principal but not all the possible specs from the types. I kept a maximum of three levels. I kept an example of these three levels. I kept examples of these three levels for each command.

I could help more people become immortal.

65. The immortal added more from the outside. I found more between the sentences. I found better features. I worked out whether a feature was good. I added round brackets to square brackets.
66. The immortal mentioned lines of algorithms between pairs of algorithms. I added more from outside. It was like an encyclopedia. Some of the notebooks needed Snakes and Ladders’ optical character recognition. There was a program finder for “subterm with address”.
67. The immortal found more between algorithm predicates. I found more between the sentences. I found connections between every consecutive sentence. I found connections between every second sentence. I found connections between every third sentence.
68. The immortal integrated the new feature. I found relevant new features. I found the algorithm type. I found the current list of features and their options. I returned the new features and options.
69. The immortal fixed or replaced the feature with the user’s help. I worked out whether a feature was good. I examined the feature’s options. I tested each one. I rated the feature’s user-friendliness.
70. The immortal used round brackets to make formulas more structured and curly brackets to represent repeating lists. I added different types of brackets. I wrote a command that was “=” with round and curly brackets, not just square brackets. I used a grammar to parse the different types of brackets when converting to C. I could pattern-match lists with each type of bracket with “=b” (sic).
71. The immortal stated that b in [a,b|[c,d]] and [a|[b,c,d]] had the same address. I connected lines of algorithms between pairs of algorithms. I listed program finders to add to or integrate into algorithms, such as graphical user interface (with text, graphics or web), algorithm induction, use of types to find tests, code and more complex tests, compilers and optimisers, state machine minimisers, and versions of subterm with address that worked with different types of data structures. For example, a subterm with an address could work with a list of forms of compounds, including the pipe (“|”) symbol. In this [a,b] in [[a,b],c,d] and 1 in [1,c,d] had the same address.
72. The immortal created the next imagined and advanced features. I added more data from outside. I didn’t solely rely on internal data, but connected to it. I wrote the most valuable additions for the best people. I only used it for recording parallels, translating and testing back-translation.
73. The immortal wrote algorithms to maintain their thoughts. The works were summarised like an encyclopedia. They were spiritual or inductive algorithms. I organised the algorithms by dependency. Each article used headings specific to the algorithm.
74. The immortal disambiguated meanings from different combinations of sections. I stated that some notebooks needed snakes and ladders' optical character recognition. The algorithm recognised the lines of text written in the margins and their characters. The output printed the text uniformly on lines. The algorithm observed horizontal and vertical dividers and numbered paragraphs.
75. The immortal decided whether the tree should have values at branching points. I stated that there was a program finder for subterm with address. I used subterm with address when finding or finding and replacing parts of multidimensional data. I identified the input and output. I determined whether linear, recursive and other variables were needed.
76. The immortal connected ideas with a story, business, or computer case study. I found more between algorithm predicates. I selected two predicates at random. I considered the significance of the places in their algorithms. This significance is related to a story, place where a new feature could be integrated, or location in the analysis of the algorithm.
77. The immortal wore smart casual wear as the founder. I found more between the sentences. I wrote music about the sentence and worked out the parts with harmonies. I found parts in which one led to another, one was a use for another, or they were related in research. I wrote a musical phrase which explored an idea’s transformation in a level.
78. The immortal specialised in neuronetworks that did slightly more complex processing, or the part beyond what was initially expected. I found connections between every consecutive sentence. The text revealed different algorithms over time. Simplicity still played a pivotal role. Neighbouring times changed the interpretation based on better hardware, new algorithms or people’s demands.
79. The immortal combined the ultra-powerful neuronetwork with algorithms to complete algorithms. I found connections between every second sentence. I captured famousness. Famousness was the delight that an intuitive feature could give at the moment, a sight, sound or the realisation what one wanted was possible.
80. The immortal practised “Lately Me (LM)” meditation. I found connections between every third sentence. I focused on the self. I focused on what I thought at each point, thinking of feedback on each idea expressed by the software. A particular algorithmic experiment changed its features with a warning responding to the user’s thoughts, input or movements.
"]