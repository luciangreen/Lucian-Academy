Finance 1 1

1. The financier undertook to replace two specs with one by inserting variables in specs. I replaced 'A1' in strings or other items in Spec to Algorithm specs with an uncommon character to detect constants or variables and substituted 'A1' if it didn't change (was a constant). In this case, the variable acted as a singleton and could be replaced with '_'. To differentiate 'A1' from similar characters in atoms, 'A1' could be represented as [var, 'A1'] for easier identification and substitution. In addition, formulas could be inserted using [formula, _] and upcase or downcase variable names and inert characters in a string according to a condition.
2. The financier marked calls or definitions as deterministic (one result) or non-deterministic (many results), with call modes overriding definition modes to determine whether to loopback or to include loops in the code. I sped up Prolog by separating input and output on compilation. I represented output as output=(a function) or retrieved the output after running the function. Separating input and output sped up code and prepared for the fastest programming language, C. This method implied separating Prolog outputs from predicate headers and the need to collect non-deterministic results as soon as possible.
3. The financier used the "Spec to Algorithm" algorithm to optimise the algorithm after identifying the necessary input and output parts. Prolog type-checked algorithms only on compilation. It generates types from the code, checking that they fit together or giving warnings to verify the code's type flow. It also generated test data that tested each algorithm feature. This test data and predicate specs could be used to optimise the algorithm in address or predicate format.
4. The financier made all predicates inside a deterministic (single result-producing) predicate deterministic. I checked external input types separately in Prolog. External input from the user, file, or APIs was not type-checked at compilation. Read string, file, and shell commands with input built-in type checking, such as type statements or grammars produced by strings to grammar. Alternatively, Spec to Algorithm returned true if a list and item grammar combination matched the list and item.
5. The financier optimised the deterministic predicate. The interpreter did not follow loops if the predicate was deterministic. The predicate mode was deterministic or non-deterministic, which caused the interpreter to delete further iterations of loops after running versions of commands that had no choice points. If a predicate contained findall with choice points, the loop was cut by "find_first" instead of findall. If findall was nested, it was transformed into nested loops.
6. The financier aimed to write a language with Rust's lifetimes and Prolog's user-friendliness that approached the speed of C. Like Mercury Language, Prolog should have no cut. It is slightly stiffer in the way that choice points in predicates are not cut during a predicate. Still, predicates may have one of a disjunction of values as a deterministic or non-deterministic result. Prolog can be converted into a no-cut form, with a determinism of predicates detected or found in parent predicates. Recursion, including intermediate recursive predicates, was represented as loops.
7. The financier saved memory with Rust's lifetimes. Rust's lifetimes found the first and last time a reference was used and deleted it afterwards. This technique was implicitly done in Prolog. It was achieved by finding the predicate and line numbers of the reference's last instance and deleting them afterwards using inserted code. This code deleted the last trace of the reference from memory.
8. The financier flattened lists for conversion to C data structures. Prolog compiled to C. I imagined the robots and everything in it. The purported version contained extensive optimisations from subterm with address and the interpreter and used S2A to reduce the complexity of complex terms. It identified terms' addresses and converted them to arrays or structures.
9. The financier kept flattened recursive structures and used array addresses for complex terms in C when converting from Prolog. I converted subterm with address to expanded code in C for optimising Prolog algorithms. I discovered the flattened version of data structures, in which addresses didn't matter, and item numbers did. If a record was a non-constant length, it was put into a table column, or these items were stored in a hash table or other fast data structure. Subterm with address found the row and column of a term, and they could be simplified to get an array address.
10. The financier efficiently compressed data to used or needed data. I converted the interpreter to optimised code. I got the first item and didn't use the non-deterministic predicate member in deterministic predicates. I joined data, referred to as a first set of data, to the first set of data if it was short enough; otherwise, I split the data into manageable segments. I referred to this data, whether it was the algorithm being run, a file or data in the algorithm (moving up the priority of frequently used data) quickly using array addresses.
11. The financier optimised state machines, breadth-first search, sort, keysort and common predicates as Prolog-to-C code. I converted Prolog terms to arrays and structures in C. I converted lists and lists of lists to arrays. Alternatively, I transformed trees into structures. I moved data to and from flattened, compressed data structures for fast processing.
12. The financier controlled their experiences in the simulation. Like a neural network is necessary for faster processing, quantum computers are required for critical future applications. Calculations are completed virtually instantly by subatomic particles and are omitted from being uploaded to classical computers. People from non-computer times could have configured simulations and saved their lives. They use thought commands and choose options to command sub-simulations.
13. The financier wrote Prolog libraries in advanced Prolog for better security and built a computer native in it. As Prolog has no mutable variable states, the Rust concept of ownership is irrelevant. In addition, Prolog variables are not "owned" in the same sense as Rust variables. Prolog employs variables with lifetimes similar to Rust. Prolog's concurrency system does not provide the same level of safety as Rust's system, which prevents data races and other concurrency issues at compile-time, which should be improved.
14. The financier used types to remove and produce errors on specific code. I removed unnecessary Prolog commands using S2A. I removed obsolete branches, commands and variables, including unused parts of code that don't contribute to the output. I used S2A to find the pattern-matching component of code, merging predicates and using the existing non-pattern-matching code. I used grammars and guess-substitution to reduce list and string lengths when finding recursive structures.
15. The financier had deterministic and non-deterministic versions of certain predicates. I changed Prolog code loops according to whether the predicate was deterministic or non-deterministic. I changed "member" to get the first item and made similar changes to append and string_concat in deterministic predicates. I replace append with list processing A=[B|C]. In addition, I replaced string_concat with a deterministic variant of string_concat.
16. The financier provided samples or shortcut commands to produce interpreters. I wrote a compiler programming language in Prolog that created an efficient compiler written in Advanced Prolog. This version of Prolog had Rust's concurrency system, and type-checking was conducted on compilation. This programming language allowed specifying specs for the interpreter or compiler and options, including website backtracking. SSI was almost fast, without processing a long list of data that could be saved to disk.