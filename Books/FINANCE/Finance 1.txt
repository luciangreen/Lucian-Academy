["Green, L 2024, <i>Finance 1</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Finance 1

1. The financier used funds to pay salaries, an office, equipment and training. To learn how to earn funds for a purpose, I studied finance. During my MBA, I studied a short course in finance. The finance course affirmed my ability to make funds. I invested in stocks and earned money from them.
2. The financier was the donor. I earned the money. I was interested in finance. I approached a possible donor. The donor had funds.
3. The financier practised finance. I got to know the donor. I politely asked how they were. Then, I asked for the money. Each statement had 50 high distinctions, with ten hand-done breasonings.
4. The financier helped people to participate in each others' academies. I found the donor through a contact. They were spiritual people. They had money through their affairs. I aimed to teach in a philosophy academy.
5. The financier stated that the donor only gave a one-off donation. For the rest, I used shares. I bought shares. I sold shares to make a profit, recording it for tax purposes.
6. The financier researched the person's hometown. I visited the place where I would do business a day before. I studied the peoples' behaviour, appearance and etiquette. I found the best restaurant and the best menu items. I invited the donor to dinner to explain my business proposition.
7. The financier returned to the first time a type statement was tested on retry. In the State Saving Interpreter (SSI) type checker, the user could retry a type statement on exit or failure. The compiler recorded the current predicate's type statement position and recursive state. This data was deleted after the type returned true or false. The recursive state saved where the point of execution was in the static structure.
8. The financier checked dynamic types online and could turn dynamic type checking on or off with explicit errors. SSI's type checker could be run on the web. Types as a compiler let the user trace through algorithms' type statements one at a time on the web. They could traverse the types state machine, with the ability to creep, skip, retry and use other trace commands such as write (writing complete trace statements) and print (printing abbreviated trace statements) and going up a level. The web required SSI rather than List Prolog Interpreter (LPI) types because LPI types couldn't save the state across multiple web pages.
9. The financier checked that the entire type statement behaved as expected. The SSI type checker allowed creeping through every stage of type checking. On a type statement, the user could creep to open it. Then, they would keep creeping until the type statement returned true or false. When a whole type statement returned true or false, creep returned to the main program's point to trace.
10. The financier debugged part of a type statement. The SSI type checker allowed skipping a type statement's trace. On a type statement, pressing \"s\" for \"skip\" in trace mode skipped over tracing the statement, returning true or false. This action was helpful for quickly checking where an error was. If the user wanted to retry a type statement of note, they could press \"r\" for \"retry\".
11. The financier examined a \"type statement\" more closely. The SSI type checker allowed retrying a type statement's trace. Retry was available through the SSI type checker because the type checker could return to a type statement, appearing to rewind a recursive state. It returned to the first instance of the type statement and its recursive state. The position in the data was also returned.
12. The financier expanded true or false results to check them. The SSI type checker allowed writing complete trace statements in a type statement's trace. I pressed \"w\" after a trace statement had been displayed to display its complete data. For example, long data was expanded from \"...\" to its entirety. This technique aided in finding detailed information to check the trace.
13. The financier abbreviated trace results for brevity. The SSI type checker allowed printing abbreviated trace statements in a type statement's trace. I pressed \"p\" after displaying a traced statement to abbreviate the display. This feature helped summarise the results. Or, it prepared quickly tracing results without taking many lines.
14. The financier could retry following going up. The SSI type checker allowed going up a level in trace mode. Pressing \"u\" for \"up\" finished all the statements and exited or failed the current type statement predicate. By repeatedly going up, I exited or failed the entire type statement. This command found the result of the set of non-deterministic type statements.
15. The financier tested more levels of lists in the type checker. I tested two, three and four-level lists in the type checker. A two-level list may be {{.}.}. A three-level list may be {.{{.}.}}. A four-level list may be {{.{{.}.}}.}.
16. The financier tested more levels of brackets in the type checker. I tested two, three and four-level brackets in the type checker. A two-level bracket may be [[.].]. A three-level bracket may be [.[[.].]]. A four-level bracket may be [[.[[.].]].].
"]