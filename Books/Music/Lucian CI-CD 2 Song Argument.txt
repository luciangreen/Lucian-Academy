["Green, L 2024, <i>Lucian CI-CD 2 Song Argument</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Lucian CI/CD 2 Song Argument

1. The refactorer tried deleting lines and joining or adding code to join lines. I stated that commands that don't give output should be kept in the new version of the algorithm in Lucian CI/CD because otherwise, these commands, connected to commands that did give output, would be deleted because they didn't affect output. I kept the writeln statement. This statement could print interpreter debugging information or game or other prompts. I kept all writeln statements, and if they needed to be deleted, they were manually deleted by deleting them and resetting the modification dates in Lucian CI/CD.
2. The refactorer collected positive and negative tests, where the negative tests traced back from failure data, particularly from if-then statements. I kept the write statement. The writeln statement was the write statement followed by writing the newline character. \"Write\" could be used to write characters in a text video game, write parts of a term written by writeln, and needed to write symbols representing illegal characters. I could save the write output to a file, which, with labels, could be checked for accuracy.
3. The refactorer tried different combinations of values instead of random outputs. I checked the random statement. A predicate with output only was checked. Random, however, had random output and couldn't be predicted. I could limit random output to a single number for testing.
4. The refactorer checked the chain of equals statements to check for a comparison, such as checking that it was a list. I possibly kept the bash command in the new version of the algorithm in Lucian CI/CD. Bash took input and gave output, where if its output was checked, it was checked. Or if it only took input and its output wasn't checked, it was kept. Its output was deemed checked if it was compared with a non-var.
5. The refactorer stated that the command was redundant if it was duplicated or the same as another command in the result. I checked read_string because it had output. As it had output, it was reviewed by Lucian CI/CD whether to keep it based on the wanted output from the predicate. If read_string provided output, optionally passed with equals and compared with a constant or other value, eventually affecting the predicate's output, and this output was wanted, then read_string was likely to be kept. It wasn't kept if redundant, providing the same result as not being there.
6. The refactorer found the minimal number of commands combined to give the correct result. The command that returned the number of rows and columns in the tty terminal window was checked. While it produced output, this could be compared with and checked for correctness on exiting the predicate. Like other commands that may or may not compare with its output, the tty command was checked for inclusion. There was no routine to check whether the output was ignored; it was only checked for correctness on exit.
7. The refactorer stated that partially checking a value had the same effect as checking it unless separate commands contributed to parts of the value. I checked the set prolog flag command. This command had no output. If the command were given input in this argument, it wouldn't be kept because it wasn't outputted. Partially comparing with a term as the output of another command had the same effect as compared with it, but in the end, all that mattered was checking it.
8. The refactorer checked that the working directory was correct. Lucian CI/CD reviewed or kept the working directory command depending on its mode. Commands' output could be split up, joined, and checked. The test finder and checker found tests and checked the code, respectively, and Lucian CI/CD reduced the code length. Lucian CI/CD found the code with the shortest length, combining the most recent and second most recent versions.
9. The refactorer stated that the halt command was kept. It returned no output. It had no arguments or one input, the status, to return. Command modes depended on their code and the data given to them. Commands' code and data could be scanned to check their mode. If a command had no output, it was kept until a human manually deleted it.
10. The refactorer recanted detailed mind reading's dog barking and crying opera versus random mind reading's two-dimensional volcano song. I stated that detailed mind reading could select against errors, for example, incorrect paraphrasing word choices, algorithm commands and writing words. Random mind reading with enough meditators supporting it, which detailed mind reading was better than, could select courses, wording of answers and details. I reduced the number of instructions in the detailed mind-reading decision tree algorithm. Detailed mind reading gave instruments a meditation-themed, or better quality, three-dimensional sound.
11. The refactorer stated that the only way of testing for security holes was to try data combinations. I found negative tests for predicates. Negative tests tested wanted failure. I tested that all consequents of if-then statements were traced to the predicate's result. I found the data types, including recurring strings' and list items' variables, and any cases where a negative result was explicitly returned at the end of the predicate.
12. The refactorer removed obsolete, extra or action-taking commands that did nothing or did the same as nothing with other commands. I tried deleting lines to join lines. I deleted lines that got in the way, were incorrect or were unnecessary to join lines. Lines got in the way if they added a number to the same variable or transformed a value of the same variable. Incorrect lines contained bugs or errors or didn't connect with other commands.
13. The refactorer found negative data from lower predicates, sometimes choosing from lists of characters rather than using \"not\" rather than selecting against undefined arguments (instead, tolerated undefined arguments and avoided deleting all commands in a predicate) when testing. I tried joining code to join lines. I changed variable names to join code. The code was already correct in either version or needed modification. Occasionally, all the commands could be deleted if the rule had enough data or negative or variable tests to stop undefined arguments.
14. The refactorer warned users but guessed if the proposed types were recommended by testing whether multidimensional terms were needed in that place. I tried adding code to join lines. I found the problematic set of lines. I found new code that would satisfy the required types. The required types, for example, multidimensional first arguments in the interpreter, were human-entered.
15. The refactorer collected positive and negative tests, where the negative tests were found tracing back from failure data, particularly from if-then statements. I also traced back from non-existent \"then\" clauses. These generated logical formulas to accompany data to find test data that satisfied them. Combinations of data were tried, and the main combinations that satisfied the formulas were used.
16. The refactorer complained that \"not\" of many variables (for example, not(a(B, C, D))) was complex and simplified to points. When there were several logical formulas operating on a variable, their conjunction was simplified. For example, (A^B)^(A^C)=(A^B^C). In addition, certain nondeterministic formulas were separated by disjunctives and simplified separately. If a formula \"not(a)\" was negated, it became \"a\".

"]