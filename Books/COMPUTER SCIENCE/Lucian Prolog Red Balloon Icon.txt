["Green, L 2022, <i>Lucian Prolog Red Balloon Icon</i>, Lucian Academy Press, Melbourne.","Green, L 2022",1,"Lucian Prolog Red Balloon Icon

1. Lucian's red balloon represented intelligence, using pedagogy.  Lucian is represented by red.  Red is positive, like Lucian.  Red represents taking action, like Lucian.  Red represents the good, like Lucian.
2. As L is to light, the first image is to the film.  Lucian is represented by \"L\".  I wanted the first image revealed by light.  I checked the available evidence from the start.  I tested and made corrections to Lucian Prolog using evidence.
3. Working Prolog code is represented by a red balloon (meaning correctness).  Prolog is represented by a balloon.  Prolog's choice-points are represented by balloons.  In mind reader, asking it any question causes it to return the answer.  The ethics were that psychoanalysis, the se for mind reader, was limited to synonymous, not private ideas.
4. List Prolog's data structures are in list format.  A list is represented by the white reflection on the balloon.  As the balloon ascends, the list is printed on.  It was in Lucian's Hand Bit Map Font, a simple bit map font which looks like handwriting.  List Prolog can run algorithms in list format.
5. I tried smaller and smaller intervals in constraint satisfaction problems, which Combination Algorithm Writer could solve.  The list, represented by the square, can be checked against knowledge, represented by the balloon.  If the list is output, it can be checked against the input to the algorithm.  If the input is a list of numbers, it can be checked against the number line or other algorithms.  The input can be tested against the output by back-substitution.
6. I noticed the reorganisation and use of earlier parts in later algorithms (the levels leading to more complex algorithms).  I found the simplest language for the sentence using mind reader by connecting it to five sentences.  I found the intersection of details for one connection.  I found the ontological categories the intersections of details for the connections fit into.  I found the best results with mind reader and chose the best result with an algorithm to find correct old words and connections and find new intersections, expressions and technologies.
7. The robot was Lucian Prolog-based.  I commented that the red balloon with a white square reflection looked robotic (the round balloon was human and the square was robot).  The robot had a humanoid body with human and robot needs and could mind read humans using mind reader.  The human created the robot.  The maker wrote Computational English to comfort the robot.
8. The robot seemed to comment that the thought waves were clearer than the messy handwriting.  I thought that the red balloon icon looked like the meeting between the digital and the analog.  The digital was the bit map graphics.  The analog was the vectors and curves.  At their interface, the robot digitally checked the analog writing with a perfect result.
9. The subject pretended God found rules from data.  I thought that the white square on the balloon looked like a message to God.  I thought that Prolog's non-determinism was easier to program in.  It allowed faster development of, for example inductive algorithms, which found algorithms from constraints such as list lengths.  I found the (n-1)th number.
10. I could simulate Shell, Java, C and Haskell in List Prolog.  List Prolog enabled me to understand Prolog better.  I noticed Prolog was interpreter-like to speed development of artificial intelligence applications.  I could design an interpreter, used to check code in different languages.  I could design algorithms that sped up mundane tasks and helped people.
11. The Lucian/List Prolog compiler compiled faster code.  List Prolog was better for artificial intelligence applications because it was more intuitive.  I found ways to improve the performance of List Prolog.  I examined faster methods than decision trees.  I used append, rather than string concatenation.
12. I noticed the science of music album naming, philosophy testing and algorithm usefulness.  I could generate algorithms in other programming languages in List Prolog.  I could help students with these algorithms.  I could learn about the algorithms by writing them.  I could save time by running these algorithms.
13. The part that preserved the formatting required knowledge of how to replace string concatenation with append for performance, so was left to the graduate to find in their career.  I simplified the algorithm to assess.  I merged the decision trees.  It was simple enough.  The part that preserved the formatting was left out.
14. The postgraduate could now perform better than the undergraduate, but needed to demonstrate more knowledge. If the lecturer chose, the algorithms  with better performance could be included, however they needed to be simple enough to find.  The student found it difficult to visualise the need for the lookahead algorithm.  Later, he traced the interpreter in List Prolog and detected the need for it.
"]