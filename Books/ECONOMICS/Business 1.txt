["Green, L 2024, <i>Business 1</i>, Lucian Academy Press, Melbourne.","Green, L 2024",1,"Business 1

1. The business person considered changing the address structure. I applied list manipulating predicates to output from \"subterm with address\". The predicate \"subterm with address\" returned the multidimensional sets of addresses of terms in a term, e.g. [1], [1,2] or [1,3,3] for 1 in 1, [2,1] and [3,3,[3,3,1]], respectively. By operating on the lists of addresses and terms at these addresses, I could change the list of data before substituting it back into the original term. For example, I might want to find items to operate on.
2. The business person wrote a simpler version of findall containing the commands. I found the member of the result of \"subterm with address\". It was part of a findall statement. I found all the results that matched particular criteria and transformed them. Before changing them, I subtracted them from all the results to keep them the same.
3. The business person simplified the language, using words instead of symbols or rewrote \"*\" as a star surrounding the variable name. I found a simpler version of findall, which just contained the commands. For example, member([*A,_],B)*C, which acted like findall(A,member([A,_],B),C). I could nest findall, for example (member([A,_], B),(member([*D,_], A)*E))*F which was equivalent to findall(E,(member([A,_], B),findall(D, member([D,_], A), E)), F). If an index was required then one could use (member([*A,_],B),get_item_n(M,A,*T))*C.
4. The business person used absolute addresses to return to the same address. I simplified \"sub term with address\". Usually, its addresses read, for example, [1], [1,2] or [1,1,1]. I could create relative addresses such as *[1], which meant the current level. Or, I could write *[2,1], which meant the first item in the second item in the current level.
5. The business person combined the data structure address with strong types. I could play with relative addresses, similar to relative file pathnames, with addresses such as *[.,1], which meant going up and choosing the level. If an address was incorrect, there was an error. I used this in an information retrieval system or labelled self-correcting data in a game. I used strong types to verify data and that the algorithm was given the correct input.
6. The business person precisely read labels at the start of each level. I used a predicate instead of strong types to verify the data structure. I changed the data structure from:
[a,
 [b,c],
 d
]
to:
[l1,a,
 [l2,b,c],
 d
]
The item \"d\" didn't need a label because it was at the same level as \"a\". I used a predicate to verify the data structure rather than types because labels could be read.
7. The business person introduced commands for most of their programs. I introduced parse and interpret commands and kept transforming an algorithm until it was in machine code. The parse command could parse a grammar, returning the text so far and an error if the grammar wasn't matched. It did this in C to save resources. I gave the command parse(String,[term=square_brackets], Output), which parsed a term.
8. The business person inspected the robot's secret example. I used the interpret command, which was needed for the robot revolution. Later, commands such as \"think\" and \"move\" were used. It was important for the robot to have swift code on its customised hardware. There was a programming language even more user-friendly than Prolog for robots, compiled strictly, open to mind-mapping and mind reading before writing code and inclusive of the human in creative decisions.
9. The business person started with a draft and finished with legally proven perfect code. I compiled the code strictly. The original code was open-slather. It was rewritten so there were no extraneous lines, choice points or unwanted logical pathways, and it was possible to add features with this strict simplicity as a prerequisite. But the code was always saved for checking.
10. The business person explored the highlights, keeping an audiovisual journal they could quickly review. The robot programming language was open to mind mapping in development. The human outlaid their wanted features, with programming requirements and everything they could imagine as a result. The exercise was available to any skill level, with software to complete the project for programmers. It was laissez-faire in that it was imaginative and emphasised teaching the robot from the start in one's thoughts.
11. The business person said the answer before it appeared. The robot programming language was open to mind-reading in development. The human controlled it. The mind reading was possible because of a glitch in the matrix and could predict thoughts, especially in music composition and philosophy mind mapping. The robot's topic, mood and appearance could adjust to one's thoughts, and a combination of a neuronetwork and mind-reading could help improve children's education.
12. The business person stored and compared their preferences over time. The robot software was inclusive of the human in creative decisions. The neuronetwork customised its thoughts to be like the person or a character. Safety features vetted this process, allowing overall positive thoughts. The human could choose their conclusion at each point for the robot, such as whether to use C-style Prolog (list decomposition) or elegant Prolog code ([A|B] in calls), whether to work or relax and which suggested filmmaking shot to make.
13. The business person kept all the memories and went on holiday at any point. I checked that there were no extraneous lines of code. I checked for duplicates or similar and unnecessary predicates. I checked for missing or extra predicate calls that were unnecessary and, when changed, made a predicate unnecessary. I avoided superfluous loops, predicates and algorithms.
14. The business person categorised the choice point and pointed out to the user that it may be dropped, affecting results, otherwise requiring hard-coding behaviour that followed a choice point. I deleted unnecessary choice points. I maintained a list of yes/no cases for if-then choice point deletions. I kept choice points in findall statements. I deleted choice points from further predicates.
15. The business person didn't unnecessarily simplify or leave data alone. I deleted unwanted logical pathways in an algorithm. For example, I found security holes in accepting certain character types and logical pathways that processed them and deleted them in the algorithm. For example, a password may be accepted, but its lowercase version may be unwantedly (sic) accepted. However, the newline character may be acceptable after a password.
16. The business person interpreted the asterisk as having various meanings. I simplified get_item_n. For example, I usually wrote get_item_n([1,2,3],1, A), returning A=1. I simplified it to [1,2,3]*[1, A]. So, B=[1,2],B*[2,A] returned A=2.
"]